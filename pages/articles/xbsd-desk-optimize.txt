====== xBSD-desk-optimize ======
<sub>{{xBSD-desk-optimize.odt|Original file}}</sub>

====== оптимизация xBSD под десктоп ======

крис касперски ака мыщъх, no-email

**операционные системы семейства ****xBSD**** — это системы для сильных духом мужчин, героически преодолевающих трудности во имя любви, любви к своей единственно правильной оси. новички в суровом мире командной строки обычно не выживают, норовя поставить себе ****KD****У, а потом удивляются почему все тормозит! оптимизация — тонкое дело! можно даже сказать — восточное! осилим ли мы его?**

===== введение =====

xBSD-системы рулят на серверах, но на десктопах они отдыхают. Сам я очень трепетно отношусь с xBSD (особенно к FreeBSD 4.5), потому что люблю консоль и привык работать с командной строкой, которую не променяю ни на какие файловые менеджеры, поскольку от BSD мне в основном требуется компилятор gcc. Для _работы_ этого вполне достаточно, а вот для развлечений, увы!

Типичный пользователь будет чувствовать себя весьма неуютно если не сможет запустить WinAmp или посмотреть видеофильм. И еще: редактировать офисные документы, открывать pdf…

{{xbsd-desk-optimize_Image_0.png}}

Рисунок 1 типичный рабочий стол среднестатистического пользователя начала XXI века

Короче, если использовать xBSD в качестве основной операционной системы, нам обязательно понадобиться GUI, иначе… это уже какой-то извращенный садомазохизм получиться с добровольной самоизоляцией от цивилизованного мира с заключением себя в монастырь. Блин! Ну на хрена мне столько камней?! Кидаются тут всякие… Я же сразу сказал, BSD люблю, и активно работаю с ней в текстовом режиме, который мне люб, дорог и мил.

{{xbsd-desk-optimize_Image_1.png}}

Рисунок 2 могучий текстовой режим командной строки, способной в руках профессионала творить настоящие чудеса

В том же самом текстовом режиме я брожу по сети через Рысь (лучший консольный браузер, в FreeBSD 4.5 — устанавливаемый по умолчанию, и непонятно почему замененный в последних версиях попсовым Links'ом который и рядом не стоял с Рысем по своим возможностям). Но это, так сказать, производство, на котором _удобно_ работать, а жить лучше где-нибудь в другом месте.

{{xbsd-desk-optimize_Image_2.png}}

Рисунок 3 лучший консольный браузер Lynx, ориентированный на работу с клавиатурой и быстрый серфинг

Первое правило распределенного программирования — не распределять программу, если это только возможно. По аналогии с этим — лучший способ оптимизации xBSD под десткоп — не использовать xBSD в качестве десктопной системы и сейчас мыщъх объяснит почему.

{{xbsd-desk-optimize_Image_3.png}}

Рисунок 4 попсовый links, выполненный в псевдографическом стиле с минимальным набором жизненно важных возможностей

===== за xBSD и против =====

Ругая Windows, которая "тормозит" и занимает столько места на диске, сколько находит, мы забываем, что KDE (или GNOME – если кто хочет играть, а не работать) тормозит еще сильнее, а места занимает столько, что…

{{xbsd-desk-optimize_Image_4.png}}

Рисунок 5 GNOME – оконный менеджер, стремящийся "догнать и перегнать" Windows… нет, это совсем не UNIXway!

Начнем с того, что в отличии от LINUX, в xBSD "десткопное окружение" не ставится из коробки и требует не только танцев с бубном, но еще и толстого канала, поскольку качать придется столько, что стоимость трафика может запросто превысить цену лицензионной копии Windows Professional, причем если последняя сразу ставится и работает, то xBSD требует кучи библиотек, поставленных в исходных текстах и влекущих обширные зависимости, которые в свою очередь влекут свои зависимости, причем старые (и легкие) версии библиотек зачастую не удается откомпилировать той версией компилятора, что поставляется в свежих релизах xBSD, а новые… они намного тяжелее, да и компилируются сложнее. Даже имея опыт работы с xBSD, собрать из нее десктоп за один день практически нереально. Одна лишь перекачка из сети и компиляция потребуют гораздо большего времени! Про то, что каждая откомпилированная программа, требует тестирования, мы скромно промолчим.

Но эти проблемы меркнут на фоне проблем с оборудованием и в первую очередь — с видео-картами. Единственная компания, которая их (изредка) пишет — это NVIDIA, остальные же, просто не обращают на xBSD внимания, поскольку на рынке десктопов она занимает такой узкий сегмент, что совсем незаметный даже по сравнению с LINUX, под которой видео-драйвера найти значительно проще (их, в частности, выпускает мой любимый Matrox и некоторые другие фирмы). Без родных или хотя бы реверсированных драйверов не удастся задействовать наивысшее разрешение и аппаратные фичи, ограничившись стандартным VGA или VESA-режимами. Ну, разрешение, впрочем, можно настроить и вручную (если, конечно, знать, какие параметры для этого необходимо передать карте). С частотой развертки дела обстоят чуть сложение, и приходится либо покупать LCD-монитор (у которых такого понятия просто нет) или подбирать необходимые параметры вручную. Все это требует знаний и времени, а время — деньги.

{{xbsd-desk-optimize_Image_5.png}}

Рисунок 6 блаженные те, кому удалось запустить KDE под xBSD

Ладно, будем считать, что KDE мы все-таки запустили, пускай и не без мата. Остается найти программы. А с программами дела обстоят довольно туго. Если под LINUX имеется хоть что-то (немного офисных пакетов, 1С бухгалтерия, пара-тройка 3D игр), то под BSD нет вообще ничего! Правда, есть возможность запускать LINUX-приложения в режиме совместимости, однако… тормоза при этом резко усиливаются, а некоторые программы вообще не запускаются! В особенности, это касается эмуляторов Windows, без которых даже под LINUX'ом очень мало, что можно сделать.

Таким образом, установка xBSD на десктоп: а) требует опыта работы с системой; б) отнимает кучу денег и времени; в) ограничивает "кругозор" небольшим пакетом программ. Зачем же искусственно создавать себе проблемы? Из любви к системе? Так из-под KDE она практически ничем не отличается от того же LINUX'а, только нормальный дистрибутив LINUX'а ставится сразу, при этом как правило занимает 1-2 диска, а xBSD требует скачивать все порты из сети, поставляясь на 4х дисках (ну, раньше на 4х, сейчас уже на 2х), в результате себестоимость установки выходит в разы дороже (вариант, когда у вас имеется бесплатный выделенный канал даже не обсуждается, поскольку многие до сих пор сидят на модемах, а KDE даже в минимальном объеме весит свыше сотни метров, да за это время можно LINUX в формате cd-business-card из сети выкачать!).

Сказанное нисколько не умоляет серверные возможности xBSD (серверу KDE на хрен не нужен) или чистой командной строки, которой, как это ни покажется некоторым странным, вполне достаточно для _работы_. Если из LINUX'а рабочую станцию можно строить из ненависти к Microsoft'у, любви к UNIX-системам или просто от бедности, то никаких убедительных мотивов зачем превращать xBSD в то, чем она не является — просто нет, да и не будет. Заметьте, сами разработчики xBSD не позиционируют свою систему как десктопную, и ничего для этого не делают, потому что не фиг. Правда, существует такая штука как PC-BSD, делающая определенные шаги в десктопном направлении и по слухам устанавливающая из коробки, но "интеллектуальность" установщика до LINUX'а все-таки не дотягивает и если LINUX сегодня легко ставят даже не имеющие с ним опыта общения вообще, то овладеть xBSD с лету не удастся!

{{xbsd-desk-optimize_Image_6.png}}

Рисунок 7 рабочий стол PC-BSD

В частности, FreeBSD 5.4 по умолчанию устанавливает уровень безопасности в 1 (даже если при установке ей явно сказать, что секьюроность идет в топку), делающий невозможным запуском X'ов (точнее, Xorg) даже из-под root'а, которые вываливаются с невразумительной жалобой на невозможность открытия /dev/io.

{{xbsd-desk-optimize_Image_7.png}}

Рисунок 8 правка файла /etc/rc/conf, ответственного за выбор политики безопасности, выбранной по умолчанию так, что запустить X'ы не может даже root

Приходится лезть в /etc/rc.conf и securelevel ручками, а для этого необходимо вообще знать как устанавливаются и конфигурируются X'ы, и новичок, впервые столкнувшийся с такой проблемой, просто не будет знать откуда следует рыть, считая, что он настроил что-то не так или чего-то недоустановил. В общем, приятное время провождение — гарантируется. При этом, ничто (и никто!) не мешает держать xBSD (вместе с другими необходимыми для работы системами) на виртуальной машине типа VM Ware, запускаемой откуда угодно — хоть из-под LINUX, хоть из-под Windows!

{{xbsd-desk-optimize_Image_8.png}}

Рисунок 9 X'ы под FreeBSD

Мыщъх повторяет еще раз — те, кому xBSD нужна для _работы_, вполне могут позволить себе раскошелится на отдельную машину или запускать ее из-под эмулятора. Остальным же рекомендуется либо Windows, либо (при наличии совести и желания приобщиться к миру свободного ПО) — LINUX. Кстати, опыт работы с LINUX'ом не очень-то помогает общению с xBSD, поскольку многое в них реализовано неодинаково, в том числе и консоль. Впрочем, справедливо и обратное. Монтирование дискеты под xBSD осуществляется утилитой mount_msdos (почему-то переименованной в последних версиях в mount_msdosfs), которой в LINUX просто нет, что вызывает удивление и страшно напрягает. Впрочем, можно включить автоматичное монтирование (но нужно ли?!) и не высаживаться. Кстати, "типичный пользователь UNIX'а постоянно вспоминает как называется команда print на этой неделе" (С). Цитате, между нами девочками, 25 лет :)

===== оптимизация =====

Учитывая все вышесказанное, задвинем в угол X'ы и будем использовать xBSD по основному назначению, работая в текстовом режиме, который можно весьма нехило оптимизировать, если знать как.

{{xbsd-desk-optimize_Image_9.png}}

Рисунок 10 нестабильная работа неправильно собранного ядра — периодически "отваливается" менеджер виртуальной памяти, выдавая сообщения vm_fault: pager read error

==== выбор компонентов ====

Главной ошибкой большинства начинающих пользователей xBSD (как, впрочем, и LINUX) является упорное нежелание (или неумение) работать с литературой. Ладно, не хотите читать объемное руководство по установке, но ведь хотя бы FAQ можно прочесть?! В отличии от LINUX'а, установить xBSD в интерактивном режиме практически невозможно! (Про проблемы запуска X'ов мы уже говорили).

{{xbsd-desk-optimize_Image_10.png}}

Рисунок 11 установка FreeBSD в текстовом режиме

Так же ни в коем случае не следует впадать в другую крайность и крутить при первой установке xBSD те настройки, которые вы не совсем понимаете. Лучше выбрать экспесс-установку и, только поработав некоторое время с системой, начинать подгонять ее под себя. Тоже самое, кстати говоря, относится и к LINUX'у. Как показывает практика, ручной выбор устанавливаемых пактов идет только во вред или, в лучшем случае, насмарку, поскольку, одни пакеты через зависимости тянут другие, в результате устанавливается даже то, от чего мы категорически отказались, а то, что мы хотели установить — не работает, потому что инсталлятор не был как следует протестирован и не смог отследить все зависимости и кое-что осталось недоустановленным.

{{xbsd-desk-optimize_Image_11.png}}

Рисунок 12 установка PC-BSD в графическом режиме

В частности, начиная с версии 3.0 (а более ранних вы все равно не найдете), компиляция модулей требует наличия исходных текстов ядра, которые простому смертному пользователю вроде бы ни к чему и многие их просто не ставят, а потом дивятся: почему модули (входящие в состав других пакетов) не компилируются?!

{{xbsd-desk-optimize_Image_12.png}}

Рисунок 13 выбор компонентов — устанавливайте исходные тексты ядра, даже если не собираетесь в них ковыряться, они необходимы для компиляции модулей

Если позволяет дисковое пространство, лучше всего выбирать полную установку, а уже потом удалять все ненужное.

==== разбивка диска ====

Дисковая подсистема все еще остается узким местом и разбивка разделов во многом определяет производительность. Если есть возможность, стоит использовать SCSI-винчестеры, поскольку у них намного более мощный планировщик запросов, чем в IDE, в результате чего компиляции приложений на SCSI-дисках занимает существенно меньшее время, чем на IDE. Если же вы собираетесь заниматься частой компиляцией, то оптимальным выбором окажется все-таки IDE с параллельным интерфейсом. SATA-контроллеры все еще достаточно сыроваты и содержат кучу ошибок, приводящих в том числе и к потерям данных, причем, потери эти могут быть очень интересными. Так, некоторые контроллеры при определенных обстоятельствах теряют последние несколько байт в последнем секторе переданного блока, в результате чего файл записывается некорректно, но если он занимает не весь кластер целиком, некоторое время ошибка остается незамеченной и проявляется только потом. Производители дешевых чипсетов с интегрированным SATA-контроллером (VIA. SiS) предпочитают исправлять такие ошибки в драйверах, естественно, выпущенных только для Windows и, возможно (хоть и маловероятно), для LINUX. Поэтому, не берите SATA для xBSD, если полностью не уверены в их безглючности!

{{xbsd-desk-optimize_Image_13.jpg}}

Рисунок 14 SATA-устройства все еще остаются достаточно сырыми и не проработанными, поэтому использовать их под xBSD не рекомендуется

Лучше всего иметь два диска, повешенные на различные IDE-каналы — один под временные файлы, swap, /var, etc, другой — под файлы системы и свои "домашние" файлы. Некоторые материнские платы поддерживают три IDE-канала, что позволяет выделить swap в отдельное "делопроизводство", однако, если на компьютере установлено хотя бы 512 Мбайт оперативной памяти, желание посвопить у xBSD практически не возникает, во всяком случае на "домашних" задачах и при компиляции приложений. Кстати говоря, сама xBSD при установке рекомендует выделить под swap пространство, равное удвоенному объему оперативной памяти. Рекомендация странная и совершенно непонятная. Здравый смысл подсказывает, что размер swap файла в первую очередь зависит от максимального объема требующейся виртуальной памяти, которая складывается из размера swap'а и величины ОЗУ. То есть, чем меньше у нас оперативной памяти, тем жирнее должен быть swap, но никак не наоборот!

{{xbsd-desk-optimize_Image_14.png}}

Рисунок 15 FDISKPartitionEditor – штатная утилита разбивки диска, входящая в стандартный установщик xBSD

Если виртуальной памяти не хватит, затребовавшее ее приложение просто завершится с ошибкой вот и все. Выделять же 512x2 == 1024 Мбайт памяти на подкачку совершенно нецелесообразно и необязательно! В первую очередь уже потому, что при разбивке по умолчанию, swap-раздел располагается между корневым и всеми остальными разделами, а это значит, что головке диска придется совершать перемещения на более далекие дистанции, вызывающие ничем неоправданное снижение производительности!

{{xbsd-desk-optimize_Image_15.png}}

Рисунок 16 разбивка диска по умолчанию — далеко не самый удачный вариант

Раздел /usr лучше всего размещать вплотную к корневому, а /swap, /var и /tmp держать на отельном диске, причем, /tmp должен идти после /var, а не наоборот. Мотив — /var не требует большого пространства (100 Мбайт будет более, чем достаточно), а вот под временные файлы следует отвести побольше, можно даже весь оставшийся объем. Если расположить /var после /tmp'а, то головка диска будет сильно порхать, поскольку ей придется при каждом обращении /tmp <-> /var пересекать весь /tmp! Зачем это нужно?! Разумнее оптимизировать раскладку разделов! Тоже самое относится и к /swap, который лучше расположить в начале диска, выделив под него сколько-нибудь памяти. "Сколько-нибудь" потому, что очень трудно убедить установщик, что подкачка нам не нужна и мы предпочитаем все данные хранить в оперативной памяти.

==== пересборка ядра ====

Все операционные системы семейства xBSD имеют монолитное ядро с опциональной поддержкой модулей, причем большая часть модулей может быть как включена непосредственно в само ядро, так и представлена динамически загружаемыми файлами. По умолчанию GENERIC-ядро включает в себя поддержку практически всего известного ему оборудования, в которое входят и SCSI-контроллеры, и сетевые карты, и много другого оборудования, которое встречается только на серверах, не говоря про все мыслимые и немыслимые сетевые протоколы, в которых и на серверах потребность далеко не всегда возникает. Естественно, что это не проходит даром и за поддержку приходится расплачиваться временем загрузки и потребляемой памятью. С другой стороны, динамические модули грузятся еще дольше! Поэтому, наилучшей стратегий будет выбор такой конфигурации ядра, чтобы все часто используемые компоненты включались в него, а редко используемые — выносились в модули.

Управление ядром осуществляется путем прямого редактирования конфигурационных файлов GENETIC и LINT, расположенных в каталоге /sys/i386/conf с последующей перекомпиляцией. Настроек, прямо или косвенно влияющих на производительность, очень много и вряд ли их можно обозреть в одной статье, поэтому ограничимся тем, что пробежимся по верхам.

{{xbsd-desk-optimize_Image_16.png}}

Рисунок 17 редактирование конфигурационного файла LINT

Выбор процессора (параметр cpu в разделе CPU Options), равно как и поддержка технологии SSE (параметр CPU_ENABLE_SSE) вопреки слухам практически ни на что не влияет, поскольку ядро само по себе не использует мультимедийных инструкций и активация SSE фактически всего лишь указывает на необходимость сохранения SSE-регистров при переключении контекстов, а это уже тормоза. С другой стороны, выключение SSE в ядре делает работу двух и более "мультимедийных" приложений невозможной и они постоянно гробятся.

{{xbsd-desk-optimize_Image_17.png}}

Рисунок 18 редактирование конфигурационного файла GENETIC

А вот задействовать поддержку многопроцессорных машин (секция SMP Options) на многоядерных кристаллах однозначно стоит! С Hyper-Threading все намного сложение и наперед очень трудно сказать, принесет ли оно увеличение производительности или нет. На некоторых приложениях наблюдается устойчивое замедление, некоторые — не реагирует на это вообще. Так что все решает эксперимент. За ним — последнее слово!

Остальные опции относятся к типу оборудования, которого по умолчанию поддерживается слишком много, но далеко не все можно безболезненно убирать. В частности, "продергивая" список SCSI-устройств нельзя забывать, что Zip на параллельном порту тоже относится к SCSI-устройствам (точнее, с помощью драйвера нижнего уровня изображает из себя таковое), поэтому если отключить поддержку SCSI-устройств (как это делают многие пользователи, имеющие только IDE), ядро не сможет увидеть Zip и… так и рождаются легенды о том, что xBSD не дружит с Zip'ом в принципе и никаких драйверов для него нет.

{{xbsd-desk-optimize_Image_18.jpg}}

Рисунок 19 на древних машинах была такая шина — ISA (длинные черные разъемы слева), ныне перекочевавшая в южный мост чипесета для сохранения обратной совместимости

Так же нельзя отключать поддержку ISA-шины, которая есть даже в тех компьютерах, в которых ее нет. В смысле на физическом уровне нет (она не распаяна на плате), но куча устройств типа динамика или клавиатуре до сих пор "вист" на ISA шине, эмулируемой южным мостом чипсета. Так что "оптимизировать" ядро следует с умом, обращая внимания на комментарии в мелочах и предварительно ознакомившись с архитектурой IBM PC в целом.

===== заключение =====

Оптимизация — это увлекательное занятие, отнимающее кучу свободного (и несвободного) времени, расходуемое на компиляцию и многочисленные эксперименты. Ведь с первого раза собрать оптимально работающее ядро навряд ли получится. Зато потом… можно ускорить систему в несколько раз! А можно ничего не выиграть вообще! Это уж от оптимизатора и мощности его оборудования зависит! Тут главное — не перестараться и не потратить на оптимизацию больше времени, чем она в принципе способна отдать назад. Тем более, не стоит ковырять стабильно работающую ось, если в этом нет жизненно важной необходимости. Как говорили древние — не ловите рыбу на золотой крючок. Если он оборвется, никакой улов не компенсирует потери. Неправильно собранное ядро запросто может перестать загружаться. Задумайтесь — сможете ли вы починить систему, не теряя текущих настроек и не прибегая к переустановке? Лучше всего заниматься оптимизацией на только что установленной системе, поскольку в этом случае нечего терять. Чрезмерное увлечение оптимизацией _всегда_ приносит больше вреда, чем пользы, а реальное ускорение дает только приобретение нового, более мощного оборудования. Потребности в памяти у BSD довольно невелики и основное внимание лучше уделить дисковой подсистеме. Более мощный процессор так же не помешает ("мощный" в смысле мегагерц), а вот от 64-разрядных камнях на рабочих станциях никакого толку по сути и нет, тем более что 64-разрядный код занимает больше места в памяти, чем 32-разрядный. Добавьте сюда проблемы совместимости (64-разрядные порты пока что недостаточно отлажены) и вы получите ответ на вопрос: стоит ли переходить на "модную" архитектуру или нет.


