====== упаковщики исполняемых файлов в LINUX/BSD\\ и борьба с ними ======
<sub>{{linux-unpack.odt|Original file}}</sub>

крис касперски, no-email

**большинство ****UNIX****-программ распространяются в исходных текстах, но количество коммерческих продуктов с закрытым кодов неуклонно растет, зачастую распространясь в упакованном виде, что не только препятствует анализу, но и снижает производительность и ухудшает совместимость с "зоопарком" ****UNIX****-клонов. покажем на примере ****UPX****, ****ELFCrypt****, ****Burneye**** и ****Shiva**** как кодокопатели освобождаются от упаковщиков**

{{INLINETOC}}
===== введение =====

В Windows упаковщики исполняемых файлов получили _очень_ большое распространение и сформировали обширную рыночную нишу, переваривающую огромные деньги, питающие целые фирмы и привлекающие высококвалифицированных специалистов, создающих нехилые защитные механизмы, борьба с которыми требует консолидации всего хакерского сообщества.

Под UNIX'ом ситуация обстоит приблизительно так: потребность в упаковщиках _уже_ есть (и многие коммерческие фирмы хотели ли бы выпустить закрытые порты своих продуктов под UNIX, основательно их защитив), но _рынок_ протекторов еще не успел сложиться, а потому разработкой упаковщиков занимается от силы десяток энтузиастов, повторяющих трюки времен ранней молодости MS-DOS и только Shiva попытался предпринять качественный рывок вперед, вплотную приблизившись к протектору SoftwarePassport (бывший Armadillo), однако, этого его и погубило. На всех LINUX/BSD-системах, до которых только смог дотянуться мыщъх ### автор, Shiva падает с криком "Segmentation fault". Какое же это счастье Window-программистам иметь одну, ну пусть две (с учетом 9x) оси, практически полностью совместимые между собой даже на уровне недокументированных возможностей!

Создание надежной защиты, запускающуюся более чем на одной версии LINUX, — практически безнадежно дело, а если вспомнить про BSD и экспериментальные ядра типа Hurd, то к программированию можно даже не приступать. В то же время, слабость защитных механизмов компенсируется отсутствуем достойного хакерского инструментария, поэтому даже простейшая защита представляет собой большую проблему, делая распаковку программ под UNIX'ом довольно нетривиальной задачей! Но мы ее решим! Начиная с самых простых упаковщиков и приобретая в сражении тактические навыки и необходимый инструментарий, в конечном счете, мы сможем сразиться с кем угодно!

===== >>> врезка упаковщики и производительность =====

При запуске файла с дискеты или CD-ROM упаковка действительно ускоряет загрузку, поскольку физически передается существенно меньший объем данных, а скорость этих устройств несопоставима со скоростью процессора, поэтому временем распаковки можно полностью пренебречь и тогда выигрыш будет численно равен степени упаковки.

При запуске с жесткого диска все происходит с точностью до наоборот. Неупакованный elf проецируется непосредственно в оперативную память и в swap вытесняются только модифицированные страницы секции данных. При запуске нескольких экземпляров неупакованного elf-файла выделения физической памяти не происходит, вместо этого операционная система просто отображает на адресное пространство процесса ранее загруженные страницы.

Если же файл упаковать, то при запуске он модифицирует всю свою проекцию целиком, а это значит, что при нехватке физической памяти операционная система уже не может "выкинуть", принадлежащие ему страницы, ведь возможности повторно загрузить их с диска уже нет и приходится заниматься вытеснением в swap. При однократном запуске программы это еще не так заметно, но многократный запуск упакованного файла приводит к существенному замедлению загрузки (ведь, вместо того, чтобы обратиться к уже загруженным страницам, операционной системе приходится заниматься распаковкой _каждый_ _раз_). По той же причине растут потребности в оперативной памяти — несколько экземпляров упакованной программы не могут совместно использовать общие страницы физической памяти. В довершении ко всему, большинство упаковщиков требуют дополнительной памяти для складывая промежуточных результатов распаковки. На утилитах, запускаемых огромное количество раз (например, make), разница между упакованным и неупакованным файлом просто колоссальна!

Отсюда вывод: //**с появлением жестких дисков и многозадачных операционных систем со страничной организацией памяти упаковка исполняемых файлов полностью утратила смысл и стала только вредить**// (она хорошо работала в эпоху господства MS-DOS, но те времена давно прошли). Теперь упаковывать (а, точнее, зашифровывать) файл стоит только ради того, чтобы затруднить его анализ, да и то… стоит ли? Хакеры все равно взломают (ни один из существующих протекторов не избежал этой участи), а вот у легальных пользователей снижается производительность и появляются проблемы совместимости ### один геморрой, тем более, что будущее все равно за открытым программным обеспечением. Как показывает практика, по мере взросления любая отрасль неизбежно приходит к открытым стандартам — взять хотя бы автомобилестроение или электронику. Лет тридцать назад японцы (в то время лидеры в этой области) закладывали в свои радиоприемники/магнитофоны ампулы с кислотой, чтобы при вскрытии корпуса все разъедало. Чуть позже для этой же цели стали применять эпоксидную смолу, а сейчас… принципиальные схемы раздаются всем сервисным центрам или отдаются пот чисто формальное соглашение о неразглашении.

===== ELF-Crypt =====

Простейший шифровщик (не упаковщик) ELF-файлов, созданный индийским студентом по кличке JunkCode (junkcode@yahoo.com) и бесплатно распространяемый в исходных текстах: http://www.infogreg.com/source-code/public-domain/elfcrypt-v1.0.html.

{{linux-unpack_Image_0.png}}

**Рисунок 1 домашняя создания JunkCode – создателя шифровщика ELFCrypt**

Шифрует кодовую секцию (которой как правило является .text) и встраивает в elf-файл крохотный расшифровщик, возвращающий ее в исходный вид. Не содержит никаких антиотладочных приемов и замечательно распаковывается под отладчиком типа gdb или ald:

<code>
:entrypoint
.080495DC: EB02	jmps	.0080495E0	; переходим на расшифровщик
.080495DE: 06		push	es		; \ мусор, оставленный...
.080495DF: C6		???			; / ...транслятором ассемблера
.080495E0: 60		pushad			; сохраняем все регистры в стеке
.080495E1: 9C		pushfd			; сохраняем флаги в стеке
.080495E2: BEC0820408	mov	esi, 0080482C0 ; начало расшифровываемого фрагмента
.080495E7: 8BFE	mov	edi, esi	; EDI := EDI (расшифровка на месте)
.080495E9: B978000000	mov	ecx, 000000078 ; кол-во двойных слов для расшифровки
.080495EE: BBBD03CC09	mov	ebx, 009CC03BD ; ключ расшифровки
.080495F3: AD		lodsd			; читаем очередной двойное слово <-----+
.080495F4: 33C3	xor	eax,ebx		; расшифровываем через xor             |
.080495F6: AB		stosd			; записываем результат на место        |
.080495F7: E2FA	loop	.0080495F3	; мотаем цикл -------------------------+
.080495F9: 9D		popfd			; восстанавливаем флаги из стека
.080495FA: 61		popad			; восстанавливаем все регистры
.080495FB: BDC0820408	mov	ebp, 0080482C0	; адрес оригинальной точки входа (OEP)
.08049600: FFE5	jmp	ebp		; передаем управление расшифрован. коду
</code>

**Листинг 1 дизассемблерный листинг расшифровщика, внедряемого ELFCrypt'ом в файл (как он выглядит в hiew'e)**

Достаточно просто установить точку сразу же за концом расшифровщика (в данном случае она расположена по адресу 80495F9h) после чего в нашем распоряжении окажется расшифрованный elf с которого можно снять дамп. В случае с dbg последовательность команд будет выглядеть приблизительно так:

<code>
root@5[elf_crypt]#objdump -f elfcrypt-demo	# определяем точку входа в файл
elfcrypt-demo:	формат файла elf32-i386
архитектура: i386, флаги 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
начальный адрес 0x080495dc

root@5[elf_crypt]# gdb elfcrypt-demo
(gdb) b *0x80495DC				# ставим точку останова на точку входа
Breakpoint 1 at 0x80495dc
gdb) r						# пускаем программу
Starting program: /home/elf_crypt/elfcrypt-demo

Breakpoint 1, 0x080495dc in ?? ()		# сработала точка останова

(gdb) display/i $pc				# говорим отображать команды ассемблера
1: x/i $pc  0x80495dc: jmp	0x80495e0
(gdb) si					# начинаем трассировать программу
0x080495e0 in ?? ()
1: x/i $pc  0x80495e0:  pusha			# продолжаем трассировать
...
0x080495f7 in ?? ()
1: x/i $pc  0x80495f7:  loop   0x80495f3	# видим цикл

(gdb) b *0x80495F9				# ставим точку останова за его концом
Breakpoint 2 at 0x80495f9

(gdb) c						# запускаем программу "вживую"
Continuing.

Breakpoint 2, 0x080495f9 in ?? ()		# точка останова достигнута
1: x/i $pc  0x80495f9:  popf			# программа расшифрована! кушать подано!
</code>

**Листинг 2 быстрая расшифровка elf-файла в отладчике gdb**

Кстати говоря, последние версии IDA Pro портированные под LINUX, содержат интерактивный отладчик в стиле Turbo-Debugger, работающий через prtace() и позволяющий делать такие вещи прямо в дизассемблере! Но специально на этот случай JunkCode подложил хакерам большую свинью, даже целых две — таких толстых, хорошо откормленных свиньи, сбивающих IDA Pro с толку.

Изменив точку входа в elf-файл (entrypoint) путем перенаправления ее на тело своего расшифровщика, он "забыл" скорректировать символьную метку _start, продолжающую указывать на оригинальную точку входа (в настоящий момент зашифрованную!), в результате чего IDA Pro показывает следующуюмуть, вводящую нас в заблуждение и высаживающую на глухую измену: ### нечто совершенно бессмысленное:

<code>
.text:080482C0	_start	proc near
.text:080482C0 8C EE		mov	esi, gs
.text:080482C2 92		xchg	eax, edx
.text:080482C3 80 5C 80 28 F9	sbb	byte ptr [eax+eax*4+28h], 0F9h
.text:080482C8 ED		in	eax, dx
.text:080482C9 57		push	edi
.text:080482CA 9E		sahf
.text:080482CB 61		popa
.text:080482CC AD		lodsd
.text:080482CD 87 C8		xchg	ecx, eax
.text:080482CF 01 D5		add	ebp, edx
.text:080482D1 B3 4F		mov	bl, 4Fh
.text:080482D3 0D B5 52 9A 61	or	eax, 619A52B5h
.text:080482D8 2D 80 C8 01 55	sub	eax, 5501C880h
.text:080482DD CC		int	3	; Trap to Debugger
.text:080482DE 33 F6		xor	esi, esi
.text:080482E0 42		inc	edx
.text:080482E1 F7 5C 99 E8	neg	dword ptr [ecx+ebx*4-18h]
.text:080482E1	_start	endp
</code>

**Листинг 3 нет, это не хитрый антиотладочный код, это просто оригинальная точка входа в программу, еще не расшифрованная расшифровщиком**

Кстати говоря, если установить точку останова на _start и дать отладчику немного поработать, мы попадем в самое начало расшифрованной программы. после чего ее будет можно анализировать в обычным режиме или снять дамп. Только эта должна быть именно аппаратная (команда "hbreak _start" в gdb), а не программная ("b _start") точка останова, иначе все рухнет (программная точка внедряет в расшифровываемую программу код CCh, который после расшифровки превращается совсем не в то, что было до нее).

Это очевидная ошибка создателя шифратора. Вот если бы он перенаправил _start в какое-нибудь интересное место, вот тогда бы хакерам пришлось попыхтеть, а так… "защита" снимается в считанные секунды безо всякого труда, однако, представляет интерес посмотреть как выглядит код расшифровщика в IDA Pro, точка входа в который, как мы помним, равна 80495DCh:

<code>
extern:80495DC 7F 01 00 00	extrn puts@@GLIBC_2_0:near
extern:80495E0 FA 00 00 00	extrn __libc_start_main@@GLIBC_2_0:near
extern:80495E4 7F 01 00 00	extrn puts:near	; CODE XREF: .plt:_puts↑j
extern:80495E4						; DATA XREF: .got:off_80495CC↑o
extern:80495E8 FA 00 00 00	extrn __libc_start_main:near
extern:80495E8						; CODE XREF: ___libc_start_main↑j
extern:80495E8						; DATA XREF: .got:off_80495D0↑o
extern:80495EC 00		extrn _Jv_RegisterClasses ; weak
extern:80495F0 00		extrn __gmon_start__ ; weak
extern:80495F0			; DATA XREF: .got:080495D4↑o
</code>

**Листинг 4 дизассемблерный листинг расшифровщика, внедряемого ELFCrypt'ом в файл (как он выглядит в IDA Pro)**

Что за чертовщина?! Каким образом расшифровщик может существовать в extern, когда здесь прямым текстом прописаны фактические адреса динамически загружаемых функций! Но тот факт, что файл все-таки работает, убеждает нас, что да — может! Просто IDA Pro в попытке "эмуляции" загрузки elf-файла пихает в externвсякую хрень, которой там нет. ### то, чего там в действительности нет

Здесь мы подходим к одной из самых любопытных особенной строения elf-файлов. В отличии от Windows, где заполнение extern'а происходит на стадии загрузки файла в память, в UNIX это делает стартовый код, причем делает он это очень хитрым способом. Ниже показан протокол трассировки программы под отладчиком с моими комментариями, отмеченными знаком ';' и содержимым дизассемблерного листинга IDA Pro, отмеченным знаком '#'. Как говориться — сравните и почувствуйте разницу!

Для облегчения понимая возьмем незашифрованную программу, необработанную ELFCrypt'ом:

<code>
(gdb) b _start			; устанавливаем точку останова на начало стартового кода
Breakpoint 1 at 0x80482c0: file ../sysdeps/i386/elf/start.S, line 47.
(gdb) r				; запускаем программу на выполнение
Breakpoint 1, _start () at ../sysdeps/i386/elf/start.S:47

(gdb) x 0x80495DC		; ок, мы в точке входа. смотрим на extern

# extern:80495DC	7F 01 00 00	extern puts@@GLIBC_2_0:near
0x80495dc:		0x00000000
; IDA Pro нас уверяет, что extern содержит адрес 0000017Fh, но в действительности
; область extern на момент запуска файла девственно чиста и забита нулями

#.text:080482C0			_start	proc near
#.text:080482C0 31 ED			xor	ebp, ebp
1: x/i $pc  0x80482c0 <_start>:	xor	%ebp,%ebp

; // незначащие машинные инструкции пропущены

#.text:080482D7 68 90 83 04 08	push	offset main
1: x/i $pc  0x80482d7 <_start+23>:	push	$0x8048390
#.text:080482DC E8 CF FF FF FF	call	___libc_start_main
1: x/i $pc  0x80482dc <_start+28>:	call	0x80482b0 <_init+56>
; но вот стартовый код вызывает библиотечную функцию ___libc_start_main,
; поскольку компилятор еще не знает ее фактического адреса,
; он вставляет переходник к секции .plt, содержащей переходники
; к секции .got, заполняемой динамическим загрузчиком

#.plt:080482B0	___libc_start_main	proc near
#.plt:080482B0 FF 25 D0 95 04 08	jmp	ds:off_80495D0
1: x/i $pc  0x80482b0 <_init+56>:	jmp	*0x80495d0
; IDA Pro корректно отобразила plt-переходник, вызывающий функцию,
; указатель на которую расположен в двойном слове по адресу 80495D0h

#.got:080495D0 E8 95 04 08 	off_80495D0	dd offset __libc_start_main
1: x/i $pc  0x80482b6 <_init+62>:	push	$0x8
1: x/i $pc  0x80482bb <_init+67>:	jmp	0x8048290 <_init+24>
; а вот тут уже начались расхождения...
; IDA Pro уверяет, что здесь расположено смещение функции __libc_start_main
; в то время как отладчик показывает, что здесь находится специальный код
; push 08h/jmp 8048290h. посмотрим, что покажет IDA Pro по адресу 8048290h

# .plt:08048290 ?? ?? ?? ?? ?? ??	dd 4 dup(?)
1: x/i $pc  0x8048290 <_init+24>:	pushl	0x80495c4
1: x/i $pc  0x8048296 <_init+30>:	jmp	*0x80495c8
; парад различий продолжается!!! IDA Pro вообще не показывает ничего!!!
; отладчик же показывает код, засылающий в стек смещение первого (считая от нуля)
; элемента таблицы .got и передающего управление по адресу, записанного во втором
; элементе таблицы .got. как следует из спецификации elf-формата, первые три элемента
; секции .got зарезервированы для служебных целей и вторая из них хранит адрес функции
; _dl_map_object_deps, которая, получив в качестве аргумента адрес начала .got'а
; читает его содержимое (а содержатся там ссылки на библиотечные функции)
; и заполняет extern фактическими адресами

0x4000bbd0 in _dl_map_object_deps () from /lib/ld-linux.so.2
1: x/i $pc  0x4000bbd0 <_dl_map_object_deps+4384>:	push %eax
; ага! вот эта функция, расположенная на моей машине по адресу 4000BBD0h,
; принадлежащему библиотеке libc.so.6 (на других машинах этот адрес может быть иным)
; она-то и выполняет всю работу по инициализации extern'а, в котором находится
; наш расшифровщик, уже расшифровавший программу, а затем вызывает __libc_start_main,
; так что загрузка динамической библиотеки происходит совершенно прозрачно
</code>

**Листинг 5 протокол отладки, иллюстрирующий ход динамической загрузки**

Вот такая, оказывается, она IDA Pro! Чтобы скрыть код от глаз исследователя, достаточно разместить его в extern'е. Для вирусов, червей и прочей малвари это очень даже актуально (особенно в свете того факта, что IDA Pro уже давно стала дизассемблером де-факто). На самом деле, IDA Pro (а точнее, elf-загрузчик) тут _совсем_ не причем, "просто мы не умеем его готовить" (С). Чтобы все заработало правильно, необходимо при загрузке файла взвести флажок "ManualLoad" и в появившимся диалогом окне "Loadingoptions" выбрать "ForceusingofPHTinsteadofSHT" (см. рис. 2).

{{linux-unpack_Image_1.png}}

**Рисунок 2 выбор альтернативного метода загрузки elf-файлов в IDA Pro**

Теперь и точка входа отображается нормально и файл можно расшифровать прямо встроенным в IDA Pro расшифровщиком (см. рис. 3), после чего продолжить дизассемблирование или снять готовый дамп.

{{linux-unpack_Image_2.png}}

**Рисунок 3 расшифровка файла непосредственно в IDA Pro**

Тот факт, что функция _dl_map_object_deps() вызывается из стартового кода, дает в наши руки универсальный способ распаковки elf-файлов, упакованных практически любым упаковщиком. Если только упаковщик не сопротивляется отладчику, достаточно всего лишь установить точку останова на _dl_map_object_deps() и... дождаться когда она сработает. Тут же в стеке по адресу [ESP+08h] будет адрес возврата из CALL __libc_start_main, а по адресу [ESP+0Ch] указатель непосредственно на саму main. Если, конечно, нам повезет… Проблемы начинаются с того, что gdb с большой неохотой устанавливает точки останова на shared-функции и потому точка останова обязательно должна быть аппаратной, причем срабатывать она может несколько раз. Левые срабатывая распознаются легко. Если по [ESP+08h] и [ESP+0Ch] лежит совсем не то, что ожидалось (а это легко определить по диапазону адресов), пропускаем текущее срабатывание точки останова и продолжаем выполнение программы командой 'c'.

Примерный сеанс работы с отладчиком может выглядеть так:

<code>
root@5[elf_crypt]# gdb elfcrypt-demo		; загружаем программу в отладчик
(gdb) hbreak *0x4000BBD0			; ставим бряк на _dl_map_object_deps
Hardware assisted breakpoint 1 at 0x4000bbd0
(gdb) r						; запускаем программу

Breakpoint 1, 0x4000bbd0 in _dl_map_object_deps () from /lib/ld-linux.so.2
; первое всплытие установленной точки останова
; сейчас будем проверять - "наше" ли оно или нет

(gdb) x $esp+8					; смотрим стек
0xbffffa6c:     0x40100498			; адрес указывает на libc.so.6
(gdb) c						; это "левое" всплытие, идем дальше
Continuing.

Breakpoint 1, 0x4000bbd0 in _dl_map_object_deps () from /lib/ld-linux.so.2
; второе всплытие установленной точки останова
; проверяем - "наше ли оно или нет

(gdb) x $esp+8					; должен быть ret из call main
0xbffffafc:     0x080482e1			; судя по адресу, это возможно так и есть

(gdb) x $esp+0xC				; должен быть указатель на main
0xbffffb00:     0x08048390			; судя по адресу это так и есть

(gdb) disassemble 0x80482e1			; проверяем наше предположение
Dump of assembler code for function _start:	; дизассемблер показывает типичный
0x080482c0 <_start+0>:  xor	%ebp,%ebp	; стартовый код, значит, приложение
0x080482c2 <_start+2>:  pop	%esi		; уже распаковано!
0x080482c3 <_start+3>:  mov	%esp,%ecx
0x080482c5 <_start+5>:  and	$0xfffffff0,%esp
0x080482c8 <_start+8>:  push	%eax
0x080482c9 <_start+9>:  push	%esp
0x080482ca <_start+10>: push	%edx
0x080482cb <_start+11>: push	$0x8048410
0x080482d0 <_start+16>: push	$0x80483b0
0x080482d5 <_start+21>: push	%ecx
0x080482d6 <_start+22>: push	%esi
0x080482d7 <_start+23>: push	$0x8048390
0x080482dc <_start+28>: call	0x80482b0 <_init+56>
0x080482e1 <_start+33>: hlt
End of assembler dump.
</code>

**Листинг 6 распаковка программы путем установки точки останова на _dl_map_object_deps**

Как вариант, изучив код распаковщика, можно написать скрипт для IDA Pro, выполняющий распаковку самостоятельно. Это хорошо работает с несложными расшифровщиками/распаковщиками, и в данном случае листинг укладывается всего в несколько строк:

<code>
auto a,x;
for(a=0x80482C0;a<0x8048338;)
{
	x=Dword(a);
	x = x ^ 0x9CC03BD;
	PatchDword(a,x);
	a = a + 4;
}
</code>

**Листинг 7 скрипт для IDA Pro, расшифровывающий программу**

Естественно, чтобы написать скрипт, необходимо знать откуда и докуда шифровать, а так же ключ шифровки, для чего необходимо проанализировать алгоритм расшифровщика (см. листинг 1). Кстати говоря, IDA Pro не обновляет модифицируемый код в окне дизассемблера (точнее обновляет, но делает это как-то странно), поэтому нам необходимо нажать <U>, разрушая ранее дизассемблированные инструкции в поток байт, а затем <C> для превращения их в дизассемблерный код.

Другой способ противодействия упаковщикам заключается в подключении (attach) к уже запущенному процессу (задолго после того, как упаковщик все уже распаковал). В gdb за это делается так: "gdb --pid=<PID>", где PID – идентификатор ломаемого процесса, который можно узнать с помощью команды "ps -a". Однако, это не самый лучший путь, поскольку мы вторгаемся в программу уже после инициализации кучи структур данных и снятый дамп может оказаться неработоспособным. К тому же из-за игр с extern'ом и несоответствия _start реальной точке входа, существующие UNIX-дамперы не могут реконструировать elf-файл, получая Segmentationfault. Правда, можно воспользоваться утитой **PD**(более подробно она рассматривается в разделе, посвященному упаковщику UPX), указав "волшебный" ключик -l, предписывающий не трогать секцию .got, тогда Segmentationfault станет вызывать сдампленный файл, но зато он будет полностью расшифрован, что (теоретически) должно существенно упростить дизассемблирование, но практически из-за отсутствия символьных имен библиотечных функций, анализ рискует превратится в пытку.

Если же снимать дамп необязательно и достаточно просто "посмотреть" что делает упакованная программа, можно использовать утилиту **ltrace**, сеанс работы с которой показан ниже. Как видно, ELFCrypt совсем не пытается ей противостоять.

<code>
__libc_start_main(0x80483c4, 1, 0xbffffb34, 0x8048410, 0x8048470 <unfinished ...>
printf(0xbffffac0, 0x40017a50, 0xbffffad8, 0x804842b, 0x6c6c6568) = 13
hello, world!
gets(0xbffffac0, 0x40017a50, 0xbffffad8, 0x804842b, 0x6c6c6568) = 0xbffffac0
+++ exited (status 192) +++
</code>

**Листинг 8 результат работы ltrace**

Помимо самых вызываемых функций, ltrace так же отражает и адреса возврата (в листинге они выделены полужирным), что позволяет нам, устанавливая на них аппаратные точки останова, врываться в любое место уже распакованной программы! В общем, не жизнь, а красота! Однако, не будем забывать, что ELFCrypt это даже не упаковщик, а экспериментальная студенческая поделка. Посмотрим, как мы сможем справится с более сложными программами… ### alt: Но справившись с ним, мы сможем справиться и с гораздо более сложными программами…

===== UPX =====

Это один из наиболее древних упаковщиков, созданный тройкой магов Markus F.X.J. Oberhumer, László Molnár и JohnF. Reiser, поддерживающий рекордное количество форматов файлов (от Амиги до UNIX) и расшифровывающий свою аббревиатуру как the "UltimatePackerforeXecutables". Свежую версию вместе с исходными текстами можно бесплатно скачать с "родного" сайта проекта: http://www.upx.org/ или с "кузни": http://upx.sourceforge.net/.

{{linux-unpack_Image_3.png}}

**Рисунок 4 авторская страница упаковщика UPX**

UPX не имеет никакого защитного кода, никак не противодействуя ни отладке, ни дизассемблированию, более того, он даже содержит встроенный распаковщик, за который "отвечает" ключ командной строки -d.

С коммерческой точки зрения UPX выгоден тем, что упакованные им файлы работают практически на всем спектре UNIX-подобных систем, однако, наличие встроенного упаковщика делает его совершенно бесполезным для защиты программ. Но это еще как посмотреть! Доступность исходных текстов позволяет слегка модифицировать структуру упаковываемого файла так, что родной распаковщик уже не сможет с ней работать.

Самое простое, что можно сделать — это затереть сигнатуру "UPX!", расположенную в конце файла, тогда UPX не сможет распознать упакованный файл, обламывая встроенный распаковщик: ### и встроенный распаковщик откажется с ним работать:

<code>
000013B390:  92 24 FF 00 55 50 58 21 │ 0D 0C 08 07 8F F1 E8 8C  Т$  UPX!♪♀◘•ПёшМ
000013B3A0:  05 97 B4 63 8C 6F 43 00 │ 19 EC 0D 00 00 41 52 00  ♣Ч┤cМoC ↓ь♪  AR
000013B3B0:  49 14 00 37 80 00 00 00 │                          I¶ 7А
</code>

**Листинг 9 сигнатура "UPX!", расположенная в конце упакованных файлов**

Проведем небольшой эксперимент. Откроем упакованный файл в любом hex-редакторе и запишем поверх UPX! что-то свое, например: "6669".

<code>
000013B390:  92 24 FF 00 55 50 58 21 │ 0D 0C 08 07 8F F1 E8 8C  Т$  6669♪♀◘•ПёшМ
000013B3A0:  05 97 B4 63 8C 6F 43 00 │ 19 EC 0D 00 00 41 52 00  ♣Ч┤cМoC ↓ь♪  AR
000013B3B0:  49 14 00 37 80 00 00 00 │                          I¶ 7А
</code>

**Листинг 10 затертая сигнатура**

Файл запускается так же, как и раньше, но теперь UPX наотрез отказывается его распаковывать:

<code>
root@5[upx-2.01-i386_linux]# ./upx -d elinks
                       Ultimate Packer for eXecutables
    Copyright (C) 1996,1997,1998,1999,2000,2001,2002,2003,2004,2005,2006
    UPX 2.01        Markus Oberhumer, Laszlo Molnar & John Reiser   Jun 06th 2006
    
        File size         Ratio      Format      Name
  --------------------   ------   -----------   -----------
       upx: elinks_2: NotPackedException: not packed by UPX
       Unpacked 0 files.
</code>
       
**Листинг 11 встроенный распаковщик UPX'а не смог распаковать файл с затертой сигнатурой**

Поскольку, UPX не использует libc и работает через интерфейс системных вызовов, то динамические библиотеки подключаются только после того, как распаковка будет завершена. А это значит, что установив точку останова на функцию _dl_map_object_deps() мы сорвем банк, ворвавшись в уже распакованную программу.

Так же сработает аттач отладчика к активному процессу. При желании можно получить не только сырой дамп, но и готовый к работе elf-файл. К сожалению, прямых аналогов знаменитого proc-dump'а под UNIX нет (команда "generate-core-file" отладчика gdb создает файл, пригодный для дизассемблирования, но, увы, не запуска), но некоторые телодвижения в этом направлении уже наблюдаются. Утилита PD, исходный код который (с объяснением принципов его работы) опубликован в 63 номере журнала "PHRAK" (www.phrack.org/phrack/63/p63-0x0c_Process_Dump_and_Binary_Reconstruction.txt) легко дампит большинство простых файлов, но со сложным пока еще не справляется (однако, оставляет шанс доработать их руками). Самое печальное, что PD не может снимать дампы программ, исполняющихся под отладчиком (а ведь в мире Windows хакеры поступают именно так! находят оригинальную точку входа отладчиком, после чего зовут proc-dump или его более современный аналог PE-TOOLS). Однако, существует возможность отсоединиться от процесса командой "detach" и до выхода из отладчика он будет находится в "замороженном" состоянии, что позволяет его беспрепятственно дампить.

Там же в статье присутствует ссылка на базовый сайт проекта (http://www.reversing.org/) но никаких новых версий там нет, так что будем пользоваться тем, что дают. Ниже показан сеанс работы с утилитой PD:

<code>
root@5[src]# ./demo			; запускаем упакованный процесс на выполнение
root@5[src]# ps -a			; определяем его pid
  PID TTY          TIME CMD
 9771 pts/7    00:00:00 demo
 9779 pts/5    00:00:00 ps

root@5[src]# ./pd -o dumped 9771	; дампим процесс в файл
pd V1.0 POF <ilo@reversing.org>
download last version from: http://www.reversing.org
source distribution for testing purposes..

performing search..
only PAGESZ method implemented in this version
AT_PAGESZ located at: 0xbffffbc8

gather process information and rebuild:
-loadable program segments, elf header and minimal size..

analyzing dynamic segment..

Agressive fixing Global Object Table..
 vaddr: 0x8049620 daddr: 0x8049000 foffset: 0x620
* plt unresolved!!!

section headers rebuild
this distribution does not rebuild section headers

saving file: dumped

Finished.				; утилита PD окончила процесс дампинга
root@5[src]# ./dumped			; запускаем полученный процесс на выполнение
</code>

**Листинг 12 снятие дампа с последующей реконструкцией elf-файла**

А вот ltrace работать не будет, поскольку она нуждается в секциях .dynsym или .dynstr, который в файлах, упакованных UNP'ом нет! Тем не менее, как было показано выше, это все равно не спасает его от взлома.

===== Burneye =====

Первый UNIX-упаковщик с претензией на протектор, созданный молодым 25-летним хакером по кличке **Scut** (scut@segfault.net), он же "TheTower", живущим в западной германии и входящим в группу TESO, в настоящее время работающей над linice – аналогом soft-ice под UNIX.

{{linux-unpack_Image_4.png}}

**Рисунок 5 сайт группы TESO**

**Burneye** — это экспериментальный протектор, распространяющийся на бесплатной основе. Сначала его исходные тексты были недоступны, но затем (под напором общественности) выложено ~30% от общего объема кода, а затем и весь проект целиком. Все это добро можно скачать с packetstorm'а.

Архив packetstorm.linuxsecurity.com/groups/teso/burneye-1.0-linux-static.tar.gz содержит откомпилированную версию, работающую под LINUX и частично под BSD ("частично" потому что иногда падает), в packetstorm.linuxsecurity.com/groups/teso/burneye-stripped.tar.gz лежит 30% исходных текстов и несколько статей с новыми, но так и не реализованными идеями по усилению защиты, а packetstorm.linuxsecurity.com/groups/teso/burneye-1.0.1-src.tar.bz2 включает в себя все исходные тексты.

Протектор умеет шифровать файлы по алгоритмам SHA1 и RC4, требуя от пользователя пароль при запуске. Теоретически взломать программу можно и без знания пароля (криптография не стоит на месте! и подходящий переборщик можно найти на http://byterage.hackaholic.org/source/UNFburninhell1.0c.tar.gz), но в практическом плане гораздо проще купить одну единственную лицензионную копию, а потом выложить ключ на всеобщее обозрение. Чтобы этого не произошло, в протектор заложена возможность "привязки" к оборудования пользователя (так называемый fingerprint). Это довольно интересная тема, но лучше оставим ее на потом, сосредоточившись исключительно на распаковке.

Burneye состоит из множества вложенных друг в друга расшифровщиков, генерируемых произвольным образом, что впрочем не сильно препятствует его трассировке, поскольку расшифровщики реализованы как процедуры. (Имеющиеся анти-дизассемблерные приемы сводятся к прыжку в середину команды и легко обходится как в IDA Pro, так и в hiew'e).

Во всем протекторе содержится всего один антиотладочный прием, препятствующий трассировке под gdb и отладчиком, интегрированным в IDA Pro.

<code>
LOAD:053714A7		mov ebx, 5			; SIGTRAP
LOAD:053714AC		mov ecx, offset anti_handler	; обработчик
LOAD:053714B1		mov edx, 30h			; signal
LOAD:053714B6		mov eax, edx
LOAD:053714B8		int 80h				; signal(SIGTRAP, anti_handler);
LOAD:053714BA		add esi, offset word_5375A00
LOAD:053714C0		mov [ebp-2DCh], esi
LOAD:053714C6		int 3				; Trap to Debugger
LOAD:053714C7		cmp anti_debug, 0		; если ноль мы под отладчиком
LOAD:053714CE		jnz short debugger_not_present
...
LOAD:05371A0C	anti_handler:				; обработчик сигнала SIGTRAP
LOAD:05371A0C		push	ebp			; (получает управление только
LOAD:05371A0D		mov ebp, esp			; при запуске без отладчика)
LOAD:05371A0F		inc anti_debug			; увеличиваем секретную переменную
LOAD:05371A15		leave				
LOAD:05371A16		retn				; выходим из обработчика
</code>

**Листинг 13 дизассемблерный листинг единственного антиотладочного приема в Burneye**

Программа устанавливает свой собственный обработчик (в приведенном выше листинге он обозначен как anti_handler), ожидающий прихода сигналов типа SIGTRAP, а затем вызывает прерывание INT 03h. При нормальном развитии событий управление получает anti_handler, увеличивающий значение переменной anti_debug, которая тут же проверяется со своим первоначальным значением. При работе под отладчиком, сигнал SIGTRAP "поглощается" отладчиком и anti_handler управления не получает.

{{linux-unpack_Image_5.png}}

**Рисунок 6 обход антиотладочного приема в отладчике, интегрированном в IDA Pro**

Основная проблема протектора в том, что переменная anti_debug проверяется в одном-единственном месте, один единственный раз! Чтобы обойти защиту можно либо записать в переменную anti_debug любое значение отличное от нуля, либо трассировать программу вплоть до достижения INT 03h, после чего "вручную" изменить значение регистра $pc на anti_debug и спокойно продолжить отладку. так же можно заменить инструкцию "cmp anti_debug, 0" на "cmp anti_debug, 1" (но это только в том случае, если в программе нет проверки целостности собственного кода). Короче вариантов много, но все они требуют участия человека, что напрягает.

Когда борьба с Byrneye всех ### хакеров окончательно достала, пацак ### хакер по кличке ByteRage (byterage@yahoo.com) написал автоматический распаковщик — **burneye****unwrapper**, по обыкновению бесплатно распространяемый в исходных текстах. Впрочем, называть "исходными текстами" крошечную Си-программу представляющую собой загружаемый модуль ядра, можно только с большой натяжкой.

{{linux-unpack_Image_6.png}}

**Рисунок 7 сайт крутого пацака ByteRage**

Качаем http://byterage.hackaholic.org/source/burndump.c, компилируем своим любимым гнутым компилятором "gcc ‑c burndump.c" (на некоторых системах необходимо явно указать включаемые файлы "gcc ‑c ‑I/usr/src/linux/includeburndump.c" и загружаем внутрь ядра "insmod burndump" (естественно, для этого необходимо иметь права root'а). Теперь, **burndump** будет сидеть резидентно в памяти и перехватывать системную функцию brk(), которая нужна упаковщику для расширения сегментов elf-файла в памяти. К моменту вызова этой функции файл уже распакован — остается только снять с него дамп и записать на диск. Чтобы не писать все подряд, необходимо как-то отождествить упаковщик. В burndump'е за это отвечает следующая малопонятная конструкция:

<code c>
	codeptr = current->mm->start_code + 1;
	/* caller == burneye ??? */
	if ((codeptr >> 16) == 0x0537)
		printk("<1> 7350 signature 0x0537 found!\n");
</code>

**Листинг 14 фрагмент burndump'а, отождествляющий упаковщик по "сигнатуре"**

Но все сразу же становится ясным, если взглянуть на файл, обработанный протектором Burnyey: как видно, протектор располагает себя по довольно нехарактерным адресам и дампер просто сравнивает 16-страрших байт адреса, вызывающего функцию brk().

<code>
.05371035: FF3508103705	push	d,[05371008]
.0537103B: 9C			pushfd
.0537103C: 60			pushad
.0537103D: 8B0D00103705	mov	ecx,[05371000]
.05371043: E93A000000		jmp	.005371082  ---↓ (1)
</code>

**Листинг 15 фрагмент файла, упакованного протектором Burneye**

После запуска упакованного файла на диске автоматически образуется распакованный ./burnout, который уже не привязывается к машине и который можно свободно отлаживать или дизассемблировать в свое удовольствие.

Выгрузка резидентного модуля из памяти осуществляется командой "rmmod burndump", но не спешите с ним расставаться! Слегка доработав исходный текст, мы сможем распаковывать и другие протекторы (когда они появятся), а не только один лишь Burneye. Дампер уровня ядра — это вещь! Это настоящее оружие с которым очень трудно справится на прикладном уровне! (Впрочем, Burneye с легкостью снимается и PD).

Короче, победу над Burneye можно считать полной и окончательной.

===== Shiva =====

Весьма амбициозный протектор, созданный двумя гуру NeelMehta и ShaunClowes (Email: shiva@securereality.com.au) и представленный ими на конференции BlackHat, проходившей в Азии в 2003 году.

{{linux-unpack_Image_7.jpg}}

**Рисунок 8 Shiva во всей своей красе**

Исходные тексты не разглашаются (как будто там есть, что скрывать!), а сам бинарник можно скачать как с сайта разработчиков www.securereality.com.au/archives/shiva-0.95.tar.gz, так и с сервера BlackHat: blackhat.com/presentations/bh-usa-03/bh-us-03-mehta/bh-us-03-shiva-0.96.tar, причем, версия с BlackHat'а посвежее будет, что наводит на определенные размышления. Там же, на BlackHat'е можно найти тексты мультимедийной презентации от обоих разработчиков и в pdf. Первый: www.blackhat.com/presentations/bh-usa-03/bh-us-03-mehta/bh-us-03-mehta.pdf и второй: http://www.blackhat.com/presentations/bh-asia-03/bh-asia-03-halvar.pdf.

Разработчики реализовали мощную антиоталадку, многоуровневую динамическую шифровку, эмуляцию некоторых процессорных инструкций… в общем получился почти что Armadillo, только под LINUX. Но, если Armadillo хоть как-то работает, то Shiva на всех доступных ## мыщъху системах выпадет в Segmentationfault. Конкретно тестировались: KNOPPIX с ядрами 2.6.7/4.2.7 и S.u.S.Ec ядром 2.6.8, пускаемых как под VM Ware, так и на "живой" машине с процессором AMD Athol-1700.

{{linux-unpack_Image_8.png}}

**Рисунок 9 неизменный Segmentationfault при попытке запустить протектор shiva, возникающий на всех доступных мыщъх'у ядрах/машинах**

Поэтому, вся информация, приведенная ниже, получена исключительно путем дизассемблирования и отладки протектора. Начнем с отладки, так как под LINUX это самый больной вопрос. Операционная система предоставляет библиотеку ptrace, которой пользуется gdb и подавляющее большинство остальных отладчиков (отладчик, интегрированный в IDA Pro, ALD – AssemblyLanguageDebugger и т. д.). Собака зарыта в том, что ptrace//**нерентабельна**//, то есть программу, уже находящую под отладкой, отлаживать нельзя! Shiva воспользовался этим фактов, породив дочерний процесс, отлаживающий сам себя (ну все как у Armadillo!), чем надежно защитился как от трассировки, так и от вызовы PTRACE_ATTACH, поскольку он тоже работает через ptrace!

Найти же удобоваримый отладчик, работающий в обход ptrace оказалось на удивление сложной задачей (тем более, что в дополнении к этому Shiva распознает TRAP-флаг, анализируя бит трассировки в регистре EFLAGS процессора и выполняет контроль таймингов). Поиск обнаруживает только кладбища заброшенных проектов. Заброшенный, заново воскрешенный и снова заброшенный ядерный отладчик **The****-****DUDE** (http://the-dude.sourceforge.net), другой ядерный отладчик — **privateICE** (http://pice.sourceforge.net/) поддерживает лишь фиксированный набор ядер и среди которых нет ни одного моего. Из всех удалось запустить только **linice** (http://www.linice.com/), да и то лишь в VGA-режиме.

{{linux-unpack_Image_9.png}}

**Рисунок 10 внешний вид ядерного отладчика linice, своеобразного аналога soft-ice для Linux**

Морской волк Chris Eagle (cseagle@nps.navy.mil) пошел другим путем и на той же самой презентации продемонстрировал поиметь Шиву во все дыры (понятное дело — морская пехота, хоть и американская). Вместо поиска отладчиков, работающий в обход ptrace, он разработал отладчик-эмулятор x86-процессора, выполненный в виде плагига для IDA Pro и бесплатно распространяемый в исходных текстах: http://sourceforge.net/projects/ida-x86emu, однако, имейте ввиду, что для его компиляции требуется IDA SDK, которая есть не у всех.

Текст мультимедийной презентации с описанием методики взлома лежит на Black Hat'e: http://www.blackhat.com/presentations/bh-federal-03/bh-federal-03-eagle/bh-fed-03-eagle.pdf, а набор утилит для взлома (включающий в себя автоматический распаковщик и несколько полезных скрипитов для IDA Pro, упрощающих расшифровку), находятся в соседнем файле: www.blackhat.com/presentations/bh-federal-03/bh-federal-03-eagle/bh-federal-03-eagle.zip.

Теперь что касается расшифровки. Чтобы противостоять дампу даже на уровне ядра, Shiva использует динамическую расшифровку по требованию (ondemand). Неиспользуемые в данный момент страницы заполняются байтами CCh, представляющими собой инструкцию INT 03h, передающую управление материнскому процессу-отладчику при попытке их выполнения, что сигнализирует о необходимости их расшифровки, которая осуществляется "подкачкой" недостающих байтов из "резервного" хранилища (Armadillo, помниться, менял атрибуты доступа страниц). Разумеется, этот трюк работает только с кодом, а с данными он не катит и их приходится расшифровывать статическим расшифровщиком.

В дополнении к этому, Shiva заменяет в расшифрованных блоках инструкции PUSH, JMP и CALL на INT 03h и эмулирует их выполнение. Все очень просто. Shiva держит в памяти специальную таблицу с адресами замещенных инструкций и если TRAP по выполнению INT 03 приходит по одному из этих адресов — врубается механизм эмуляции. В практическом плане это означает, что даже расшифровав _все_ зашифрованные блоки, мы все равно не сможем избавиться от SivaRTL (среды исполнения) и будем вынуждены "тащить" упаковщик за собой, если конечно, не декодируем эту таблицу адресов и не восстановим "украденные" команды.

Для противодействия дизассемблеру Shiva генерирует большое количество полиморфного кода и постоянно совершает прыжки в середину инструкций, что ужасно напрягает. 

{{linux-unpack_Image_10.png}}

**Рисунок 11 структура файла, зашифрованного Шивой**

Короче говоря, Shiva это кривая калька с Armadillo и к тому же неработающая. В то время как под Windows, протектор Armadillo уже давно не является чудом инженерной мысли, ситуация в мире UNIX напоминает СССР в эпоху "персональных компьютеров коллективного использования".

===== заключение =====

Через несколько лет, когда рынок закрытого программного обеспечения под UNIX достигнет критической точки, упаковщики исполняемых файлов, _возможно_ начнут играть существенную роль, но пока же они годятся разве, что для забавы и… подготовке к схватке с по-настоящему серьезным противником. Хакерские утилиты под UNIX уже пишутся и к тому моменту, когда защитные механизмы выйдут на арену, разработчики с удивлением обнаружат, что ситуация совсем не та, что пару лет назад и теперь им противостоят не пионеры, ковыряющие внутренности UNIX'ов в свободное время от основных дел, а хорошо подготовленные специалисты, которых никаким протектором не запугать.

===== >>> врезка сводная таблица свойств упаковщиков =====

|характеристика|ELF-Crypt|UPX|Byrneye| Shiva|
|anti-debug|нет|нет|да|да|
|anti-dissembler|есть|нет|да|да|
|anti-ltrace|нет|да|да|да|
|allow to attach|да|да|да|нет|
|anti "procdump"|да|нет|нет|да|
|интерфейс|libc|syscall|syscall|syscall|
|содержит распак.|нет|да|нет|нет|
|взломан|да|да|да|да|

**Таблица 1 основные характеристики наиболее популярных UNIX-упаковщиков (неблагоприятные для хакеров свойства затемнены)**

===== >>> выноска ссылки =====

# страничка shiva

http://www.securereality.com.au/

http://www.securereality.com.au/archives/shiva-0.95.tar.gz



# Neel Mehta Advanced in ELF Runtime Binary Encryption - Shiva

http://www.blackhat.com/presentations/bh-usa-03/bh-us-03-mehta/bh-us-03-mehta.pdf

http://www.blackhat.com/presentations/bh-usa-03/bh-us-03-mehta/bh-us-03-shiva-0.96.tar

#Shaun Clowes A Security Microcosm - Attacking/Defending Shiva, A Linux Executable Encryptor

http://www.blackhat.com/presentations/bh-asia-03/bh-asia-03-halvar.pdf

#Chris Eagle Strike/Counter-Strike: Reverse Engineering Shiva

http://www.blackhat.com/presentations/bh-federal-03/bh-federal-03-eagle/bh-fed-03-eagle.pdf

http://www.blackhat.com/presentations/bh-federal-03/bh-federal-03-eagle/bh-federal-03-eagle.zip

# ida-x86emu

http://sourceforge.net/projects/ida-x86emu

# upx

http://upx.sourceforge.net/

#elfcrypt

http://www.infogreg.com/source-code/public-domain/elfcrypt-v1.0.html

# Burneye ELF encryption program, x86-linux binary, version 1.0 - new year release!

http://packetstorm.linuxsecurity.com/groups/teso/burneye-1.0-linux-static.tar.gz

#Burneye ELF encryption program 1.0.1 with full source and docs.

http://packetstorm.linuxsecurity.com/groups/teso/burneye-1.0.1-src.tar.bz2

# Stripped burneye sources, for educational purposes (beside the speech + article).

http://packetstorm.linuxsecurity.com/groups/teso/burneye-stripped.tar.gz

# TESO Burneye Unwrapper

http://www.securiteam.com/tools/5BP0H0U7PQ.html

# пример защищенного файла

# Модуль  перехватывает  работу  системного  вызова  brk(),  анализирует  память

# процесса в контексте которого он работает, и по сигнатуре определяет burneye на

# нужной нам стадии, а потом просто банально дампит дешифрованный elf на диск.

# Ну а дальше всё просто:

# gdb или ltrace..

# И таким образом получаем:

# login=ZincompetenciaZ&password=ZgalopanteZ

http://quiz.ngsec.com/game1/level10/validate_MoD

# как ломанули debian

http://www.debian.org/News/2003/20031202.ru.html

# procdump for linux

# Advances in remote-exec AntiForensics

http://www.phrack.org/phrack/63/p63-0x0c_Process_Dump_and_Binary_Reconstruction.txt

http://www.phrack.org/phrack/63/p63-0x0c_Process_Dump_and_Binary_Reconstruction.txt

http://www.reversing.org/node/view/10

# шифрованиев linux

# Next-generation runtime binary encryption using on-demand function extraction  

http://www.phrack.org/phrack/63/p63-0x0d_Next_Generation_Runtime_Binary_Encryption.txt

http://www.phrack.org/phrack/63/p63-0x0d_Next_Generation_Runtime_Binary_Encryption.txt

#Armouring the ELF: Binary encryption on the UNIX platform

http://www.phrack.org/show.php?p=58&a=5


