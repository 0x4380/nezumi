====== overHAL.hacker-edition ======
<sub>{{overHAL.hacker-edition.odt|Original file}}</sub>

====== основы ядерной инженерии ======

крис каперски ака мыщъх

**традиционно ****Windows**** считается закрытой системой, залезть внутрь которой на предмет "чего-то там подкрутить" так же трудно, как и вылезти потом обратно. толи дело ****LINUX****, позволяющая перестраивать себя как угодно, вплоть до замены ядра. на самом деле, менять ядра можно и в ****Windows****, главное знать как! эта статья затрагивает следующие системы: ****Windows****NT****, 2000, ****XP****, 2003. пользователи ****Windows ****9****x****/****Me****, увы, **Kris Kaspersky0000-00-00T00:00:00n2kпривет-привет, ОК путь это будет инженерия, будем говорить лишь о смене ядер, лишь мельком упомянув разгон. интро полностью переписано. по "не каждый тест" – не надо издеваться, сначала надо разобраться как работает тест. я же говорю, делает серию замеров и откидывает замеры с набольшими отклонениями (затронутые переключениями контекста). так поступает любой тест, даже если вообще ничего не знает ни о контекстах, ни о переключениях. обычная метрология, которую по идее должны учить во всех институтах ;) 

**отдыхают**Bob0000-00-00T00:00:00BПривет, Крис! В названии статьи скорей всего не будет упоминаться разгон. Тем более что результаты этого разгона еще и не каждым тестом промеришь :) Имхо, лучше говорить об этом как о любопытном эксперименте с необычными побочными эффектами. И название статье подобрать соответствующее - что-нибудь вроде "Ядерные реакции" "Ядерные технологии" или "Основы ядерной инженерии" :) Так что такое интро не катит...  Может быть стоит превратить в интро первое предложение  введения?





===== введение =====

Все началось с того, что на одном из Интернет-форумов (сейчас никто уже и не помнит на каком) появилось сообщение о новом способе разгона Windows XP суть которого в общих чертах сводилась к замене стандартного ядра, которым как правило является ACPI-ядро, на "Standard PC with C-Step i486", после чего производительность системы якобы существенно возрастала. Информация не осталась незамеченной и вызвала бурную дискуссию, быстро переросшую в жаркий флейм. Спорящие стороны с умным видом обсуждали темы в которых ни хрена не понимали и оперировали тезисами в стиле "если бы это было правой, M$ уже давно засудили" и "где такую траву брал?!". Реальную замену ядра осуществили единицы. У одних система воспряла духом и завращалась быстрее прежнего, другие же не обнаружили никаких изменений в производительности.

Сам автор, активно экспериментирующий с ядрами еще во времена Windows NT 4.0, подтверждает: да, замена ядра может дать ощутимый прирост производительности, но о ACPI и многих других современных вкусностях вам придется забыть. Кстати говоря, это //документированная// особенность поведения системы, и никакого подвоха здесь нет. Не верите мне – спросите у Microsoft.

===== ядерная хирургия =====

Существует несколько способов смены ядер (автору известно по меньшей четыре из них), самым известный из которых сводится к переустановке операционной системы и нажатию клавиши F5 во время тестирования конфигурации ("//Press////F////6 ////if////you////need////to////install////a////third////party////SCSI////or////RAID////driver////"/"Нажмите F6, если Вам необходимо загрузить SCSI или RAID драйвер стороннего производителя"//). Нет, это не ошибка! Когда вас просят нажать F6, вы должны нажимать F5. Вот такая она Microsoft!

Если никаких клавиш не трогать, Windows автоматически выбирает наиболее подходящее с ее точки зрения ядро (если, конечно, не ошибется). F7 отменяет тестирование и назначает стандартное ядро по умолчанию, а F5 форсирует выбор ядра вручную. В штатный комплект поставки Windows XP входят около десятка различных ядер, перечисленных в таблице 1.

Тип ядра должен соответствовать типу оборудования. Так, например, работа стандартного ядра на многопроцессорной материнской плате (даже если на ней установлен всего лишь один процессор) не тестировалась Microsoft и потому не гарантируется. Однако, в подавляющем большинство случаев, все работает, поэтому, экспериментируйте не боясь.

|**английское/русское название разных ядер**|**для каких компьютеров предназначено**|
|ACPI Multiprocessor PC|ACPI-системы с многопроцессорной системной платой и двумя или более установленными процессорам|
|Многопроцессорный компьютер с ACPI| ::: |
|ACPI Uniprocessor PC|ACPI-системы с многопроцессорной системной платой и одним установленным процессором|
|Однопроцессорный компьютер с ACPI| ::: |
|Advanced Configuration and Power Interface (ACPI) PC|ACPI-системы с однопроцессорной системной платой|
|Компьютер с ACPI| ::: |
|MPS Uniprocessor PC|не ACPI-системы, с многопроцессорной системной платой и одним установленным процессором|
|Однопроцессорный компьютер с MPS| ::: |
|MPS Multiprocessor PC|не ACPI-системы, с многопроцессорной системной платой и двумя или несколькими установленными процессорами|
|Многопроцессорный компьютер с MPS| ::: |
|ACPI Compaq SystemPro Multiprocessor or 100% compatible|компьютеры типа Compaq SystemPro или полностью совместимых с ними|
|Многопроцессорный CompaqSystemPro или 100% совместимый| ::: |
|Standard PC|любой стандартный компьютер – не ACPI, с однопроцессорной системной платой (если плата поддерживает ACPI, то система ее заблокирует)|
|Стандартныйкомпьютер| ::: |
|Standart PC with C-Step i486|однопроцессорные компьютеры с процессором 80486 Step-C (степпинг С, разновидность i486) или выше, без поддержки ACPI|
|Стандартный компьютер I486 степпинг-С| ::: |

Таблица 1 ядерное меню, предлагаемое установщиком Windows

Преемственные версии ядер можно переключать и без установки системы, просто заменяя файлы //библиотеки аппаратных абстракций// – //**H**////ardware////**A**////bstraction////**L**////ayer//или сокращенно **HAL** (по умолчанию hal.dll) и //исполнительной системы// – //Executive////System//, так же называемую KERNEL'ом (по умолчанию ntoskrnl.exe, не путать ckernel32.dll – он совсем из другой оперы). Вместе они и образуют ядро операционной системы, на котором держаться все остальные компоненты, подробнее об этом рассказывается во врезке "внутри ядра".

В "Панели Управления" (ControlPanel) щелкните по иконке "Система" (System), войдите в "Диспетчер Устройств" (DeviceManager), находящиеся во вкладке "Оборудование" (Hardware), в списке устройств найдите "Компьютер" (Computer), дважды щелкните по нему мыщъх'ем, раскрывая иерархическую ветвь, из которой выпрыгнет "Компьютер с ACPI"/"AdvancedConfigurationandPowerInterface (ACPI) PC" или что-то в этом роде. Левой клавишей вызовете "Свойства" ("Properties") и в закладке "Драйвера" (Drivers) нажмите "Обновить драйвер" (UpdateDriver). Если этой закладки нет, значит, вы не обладаете правами администратора.

"Диспетчер Устройств" предложит вам на выбор одно или несколько преемственных ядер, которые вступят в строй сразу же после перезагрузки. Правда, если обновление пройдет неудачно, система наотрез откажется загружаться. Обычно это происходит при попытке обновления стандартного ядра до ACPI или наоборот. Дело в том, что ACPI и не-ACPI ядра используют различные дерева устройств и по-разному распределяют системные ресурсы (подробнее см. врезку "что такое ACPI"). Диспетчер Устройств позволяет переключать только преемственные версии ядер, однако, иногда он ошибается и систему приходится чинить. Удерживая F8 при запуске Windows, дождитесь появления загрузочного меню. Войдите в "LastKnownGoodConfiguration" и, выбрав подходящий профиль оборудования, скажите "Configuration Recovery".

{{overhal.hacker-edition_Image_0.png}}

Рисунок 1 переключение ядра "на ходу" с помощью Диспетчера Устройств

Для обхода ограничений, свойственных Диспетчеру Устройств, предусмотрен чисто хакерский способ ручного переключения ядер, позволяющий выбирать не преемственные ядра (или ядра, выдернутые из других дистрибьютивов Windows), а так же организовывать многовариантную загрузку. Для этого необходимо отредактировать файл **boot****.****ini**, находящийся в коневом каталоге загрузочного диска. Откройте его в "Блокноте" или любом другом аналогичном редакторе и найдите следующую строку.

multi(0)disk(0)rdisk(0)partition(1)\WINNT="Windows XP Professional" /fastdetect /SOS

Листинг 1 строка загрузочных параметров файла C:\boot.ini

Теперь либо добавьте к ней два новых ключа /KERNEL= и /HAL= указав имена файлов исполнительной системы ядра и уровня аппаратных абстракций, либо выделите всю строку целиком и вставьте ее в конец файла boot.ini, изменив текст "Windows XP Professional" на что-нибудь в стиле "Windows XP hacked". Тогда при старте системы на экране появится меню многовариантной загрузки, позволяющее быстро переключаться между различными версиями ядер, не рискуя при этом обрушить основную конфигурацию системы (если это меню не появится, нажмите <F8>).Bob0000-00-00T00:00:00BТы был прав, Крис,  надо делать фотку блокнота + окошко апплета «Загрузка и восстановления операционной системы » (там где поле со списком вариантов хзагрузки:) – я потом эти два скрина скомбинирую в один в фотошопе.

Kris Kaspersky0000-00-00T00:00:00n2k ну… думаю, что я достаточно подобрал интересных иллюстраций и "блокнот" отдыхает, что же до загрузочного меню – увы, снимать его копию с экрана мне нечем ;( если у тебя есть цифровик, попробуй это сделать сам. у меня цифровика нету ;(



Если выBob0000-00-00T00:00:00BОпять ты к читателю на «вы» :) Знаешь  как трудно потом эти «вы» вычесывать :)

Kris Kaspersky0000-00-00T00:00:00n2kвидишь ли, в большинстве изданий к читателю требуется обращаться на "вы" и я к этому настолько привык, что "вы" у меня выскакивает непроизвольно. но я думаю, что лучше чисто "вы" чем смесь с "ты" на "вы" наполовину.

 не устанавливали никаких ServicePack'ов, откройте каталог WINNT\System32\Driver Cache\i386\driver.cab и вытащите из него файлы, название которых начинается с **HAL**. Затем найдите файлы, содержащие "nt" и "kr" (в FAR'е для этого достаточно нажать Gray-<+> и "*nt*kr*"). Скопируйте их в каталог WINNT\System32. Для тех, у кого Service Pack установлен: ищите указанные файлы в каталоге WINNT\ServicePackFiles\i386.

Руководствуясь таблицами 2, 3 и 4, выберите ядро свой мечты, вписав соответствующие HAL'ы и KENREL'ы в boot.ini, отредактированный вариант которого может выглядеть, например, так:

multi(0)disk(0)rdisk(0)partition(1)\WINNT="Windows XP Professional" /fastdetect /SOS

multi(0)disk(0)rdisk(0)partition(1)\WINNT="Windows XP hacked" /fastdetect /SOS /HAL=HALMPS.DLL /KERNEL=NTKRNLMP.EXE

Листинг 2 пример многовариантной загрузки Windows XP

Сохранив изменения в boot.ini файле, перезагрузитесь. Имейте ввиду, что если вы отредактируйте файл неправильно, система может "подавиться" при его загрузке, наотрез отказываясь запускаться! Если это произошло, подключите винчестер с "упавшей" Windows к системе с работающей NT (не обязательно той же самой версии, что и у вас)Bob0000-00-00T00:00:00BПочему NT, а не XP? Вообще, на фига у тебя выползли NT, 2000 – говорил бы только об XP, хлопот было бы меньше :)

Kris Kaspersky0000-00-00T00:00:00n2kпотому что XP это NT 6.0 ;) а на w2k сидят очень много пользователей – им что, не интересно как ядро заменить? а XP это скась и мась дай и ну ее наХеР.

, повестив его вторым (SecondaryMaster или Primary/SecondarySlayer) и скопируйте исправный boot.ini на свой диск. Ну или просто переустановите систему.Bob0000-00-00T00:00:00BСлушай, вот тут не понятно – если ты написал boot.ini с многовариантной загрузкой, то как система может не стратовать? Просто выбираешь при загрузке исходный вариант и все. Или я что-то не допонимаю?

**Kris Kaspersky0000-00-00T00:00:00n2k еще как может! если сам boot.ini окажется запорчен, то до многовариантной загрузки дело не дойдет и система остановится. ОК, изменил "сделаете что-то не правильно", на "неправильно отредактируете файл"

**

|**компонент ядра**|**целевое назначение**|
|NTOSKRNL.EXE| исполнительная система для однопроцессорных ПК c физической памятью 4 ГБ или меньше|
|NTKRNLMP.EXE| исполнительная система для многопроцессорных ПК с физической  памятью 4 ГБ или меньше|
|NTKRNLPA.EXE| исполнительная система для однопроцессорных ПК c физической памятью свыше 4 ГБ|
|NTKRPAMP.EXE|исполнительная система для многопроцессорных ПК с физической памятью свыше 4 ГБ|
|HAL.DLL| стандартный HAL (не ACPI, не Kris Kaspersky0000-00-00T00:00:00n2kобъяснено во врезкеAPIC)|
|HAL486C.DLL| HAL для i486 C-Kris Kaspersky0000-00-00T00:00:00n2kобъяснено в табл. 1Stepсистем|
|HALAPIC.DLL| однопроцессорная версия HALMPS.DLL (не ACPI, APIC)|
|HALAST.DLL| для симметричных многопроцессорных систем от компании AST|
|HALMPS.DLL| для большинства многопроцессорных систем на базе Intel (не ACPI, APIC)|
|HALACPI.DLL| однопроцессорный HAL с поддержкой ACPI, не APICBob0000-00-00T00:00:00BНе? Или «но не»Kris Kaspersky0000-00-00T00:00:00n2kACPI и APIC это разве вещи, поэтому "но не" не катит. "гиря тяжелая, но не зеленая" ;)|
|HALAACPI.DLL| однопроцессорный HAL с поддержкой ACPI и APIC|
|HALMACPI.DLL| многопроцессорный HAL с поддержкой ACPI и APIC|

Таблица 2 описание наиболее распространенных ядер**Bob0000-00-00T00:00:00BСлушай, а нельзя сказать «версия ядра»? Если это корректно, то имхо – лучше звучит.

****Kris Kaspersky0000-00-00T00:00:00n2k"версия" понятие растяжимое. у того же HALAPIC.DLL куча версий в рамках одной библиотеки, так что нас могут неправильно понять…

**



| |HAL.DLL|HAL486C.DLL|HALAPIC.DLL|HALAST.DLL|HALMPS.DLL|HALACPI.DLL|HALAACPI.DLL|HALMACPI.DLL|
|HAL.DLL| |**+**|**+**|**+**|**+**|**–**|**–**|**–**|
|HAL486C.DLL|**+**| |**+**|**+**|**+**|**–**|**–**|**–**|
|HALAPIC.DLL|**+**|**+**| |**+**|**+**|**–**|**–**|**–**|
|HALAST.DLL|**+**|**+**|**+**| |**+**|**–**|**–**|**–**|
|HALMPS.DLL|**+**|**+**|**+**|**+**| |**–**|**–**|**–**|
|HALACPI.DLL|**–**|**–**|**–**|**–**|**–**| |**+**|**+**|
|HALAACPI.DLL|**–**|**–**|**–**|**–**|**–**|**+**| |**+**|
| HALMACPI.DLL|**–**|**–**|**–**|**–**|**–**|**+**|**+**| |

Таблица 3 преемственность различных HAL'ов, знак "-" (выделен красным) обозначает, что замена требует переустановки операционной системы, знак "+" (выделен голубым) означает, что переустановка не требуется



| |NTOSKRNL.EXE|NTKRNLMP.EXE|NTKRNLPA.EXE|NTKRPAMP.EXE|
|HAL.DLL|**+**|**–**|**+**|**–**|
|HAL486C.DLL|**+**|**–**|**–**|**–**|
|HALAPIC.DLL|**+**|**–**|**+**|**–**|
|HALAST.DLL|**+**|**+**|**–**|**+**|
|HALMPS.DLL|**–**|**+**|**–**|**+**|
|HALACPI.DLL|**+**|**–**|**+**|**–**|
| HALAACPI.DLL|**+**|**–**|**+**|**–**|
|HALMACPI.DLL|**–**|**+**|**–**|**+**|

Таблица 4 таблица совместимости HAL'ов с KERNEL'ами, знаком "+" помечтаны совместимые комбинации

===== так много ядрышек хороших… =====

Какую версию ядра выбрать? Это зависит от архитектурных особенностей компьютера и ваших непосредственных потребностей. Таблица 2 описывает назначения некоторых наиболее популярных ядер, из которых в первую очередь хотелось бы обратить внимание на NTKRNLMP.EXE/HALMPS.DLL, ориентированных на многопроцессорные системы. Если вы установили Windows на компьютер без поддержки Hyper-Threading, а затем неожиданно решили ее поддержать, купив новехонький Pentium-4, Windows не захочет работать со вторым процессором до тех пор, пока вы не переустановите ее или… не замените ядро. Второе, естественно, проще и быстрее. Кстати, о быстроте…

Ходят слухи, что ядра с Kris Kaspersky0000-00-00T00:00:00n2kобъяснено во врезке

поддержкой ACPIпроигрывают не-ACPI ядрам по скорости. И хотя доля правды здесь есть, в общем случае это не так. Нормально работающий ACPI не тормозит систему, если конечно ничего не конфликтует и не глючит, а конфликтует он удручающее часто поскольку задиристый как петух и монстроузный как мамонт. В частности, чипсеты VIA, SiS, ALI, RCC славятся хреновой реализацией PM-таймера (PowerManagementTimer), приводящего к зависанию системы или "дрыгательному" воспроизведению аудио/видео-файлов. Проблема лечится переходом на чипсеты от Intel/AMD (они самые правильные) или установкой ServicePack'а (подробнее об этом рассказывается в технической заметке Q266344 в Базе Знаний Microsoft). Кстати говоря, сравнивая производительность ACPI и не-ACPI ядер, не забывайте, что они используют различные таймеры для измерения времени, которые между прочим никто не калибровал, поэтому бенчмарки разных ядер могут существенно различается уже за счет одной лишь инструментальной погрешности! Другая проблема связана с охлаждением процессора путем его автоматического отключения во время простоя системы. Некорректная поддержка ACPI зачастую приводит не только к 100% загрузке ЦП, но и к характерному треску во временя проигрывания аудио-файлов! К тому же многие ACPI-системы поддерживают динамическое управление производительностью, подбирая тактовые частоты и тайминги в соответствии с текущими потребностями, если конечно ACPI-контроллеру удастся их "угадать". Еще ACPI пытается "оптимизировать" системные ресурсы, вешая все прерывания на одно IRQ. Вообще говоря, эта ситуация вполне нормальна (см. техническую заметку Q252420 в Базе Знаний Microsoft), однако, для достижения наивысшей производительности все устройства лучше развести по своим прерываниям.

Многопроцессорные ядра самые медленные (почему – см: "разгон ядра и его последствия"). Использовать их на однопроцессорных машинах не рекомендуется (ну разве что вы хотите поэкспериментировать).

Ядро, доставшееся в "наследство" от 486-машин, самое быстрое, однако, и самое ограниченное в своих функциональных возможностях. При использовании современного оборудования и некоторых навороченных игрушек могут появится серьезные проблемы от полного нежелания работать, до периодических сбоев или чудовищного торможения всей системы. Некоторые "специалисты" авторитетно утверждают, что выбирая i486, можно забыть про SIMD и SSE2, что не ускоряет, а наоборот, замедляет систему. Хотел бы я посмотреть кто таких "специалистов" делает… Никакого отношения к SIMD/SSE2-командам ядро не имеет, ведь не оно же их исполняет! Другой вопрос, что при переключениях с одной задачи на другую, все SIMD/SSE2 регистры должны быть сохранены, иначе совместная работа двух и более мультимедийных приложений станет невозможной. Дизассемблирование подтверждает, что i486 ядро использует команду FXSAVE, автоматически сохраняющую все SIMD/SSE2 регистры, так что волноваться за это не надо! Кстати говоря, в штатный комплект поставки Windows 2000 это ядро не входит, однако, его вполне реально найти в Интернете или попробовать выдернуть из дистрибутиваWindows XP, но никаких гарантий, что оно нормально встанет на Windows 2000 ни у меня, ни у вас нет. Экспериментируйте на свой страх и риск.

{{overhal.hacker-edition_Image_1.jpg}}

Рисунок 2 ACPI-контроллер, вживленный в южный мост чипсета

===== разгон и его последствия =====

Смена ядра не заставит процессор вычислять синус угла быстрее и уж точно не расширит пропускную способность интерфейсных шин. Популярные тестовые программы для измерения быстродействия ядер также не годятся, поскольку не обнаруживают никакого прироста производительности, даже тогда, когда разница видна невооруженным взглядом. Почему так происходит? Все очень просто. "Быстрые" ядра отличаются от "медленных" прежде всего накладными расходами на обработку Kris Kaspersky0000-00-00T00:00:00n2kзаменил термин "диспетчеризация" на "обработка"

прерываний и Kris Kaspersky0000-00-00T00:00:00n2kзаменил "контекст" на "переключение между задачами".

переключений между задачами. Промежуток времени между двумя переключениями (условно называемый квантом) это целая вечность для процессора, в течении которой он успевает обсчитать множество тестовых задач, в результате чего длительность переключений просто не учитывается. К тому же, при малом числе потоков, издержки от переключений между ними достаточно невелики, но стоит запустить параллельно с тестовой программой десяток-другой тяжеловесных приложений, как все измениться!

Практика показывает, что на компьютерах, оснащенных SDR-памятью и процессорами с частотой менее 1 ГГц, i486-ядро существенно повышает "Kris Kaspersky0000-00-00T00:00:00n2kладно, нехай будет отзывчивость

отзывчивость"Bob0000-00-00T00:00:00BА слово «отзывчивость» не подойдет? :)

 системы и работать с ней становится значительно приятнее. Для проверки запустите пару десятков приложений (обычное состояние системы к концу рабочего дня, не правда ли?) и замерьте время выполнения контрольной задачи (например, наложения фильтра на гигабайтный рисунок в Photoshop, компиляцию мегабайтного файла, контекстный поиск в тысяче страничном pdf'e).

Естественно, с ростом быстродействия компьютера замена ядра дает все меньший и меньший выигрыш быстродействия, но даже на мощных рабочих станциях он остается заметным (видишь сурка? я тоже не вижу. но он есть!). Попутно исчезают конфликты присущие не вполне ACPI-совместимым устройствам, драйверам и BIOS'ам. На смену им приходят конфликты с древней версией ядра, на совместимость с которой ни устройства, ни драйвера, ни BIOS'ы вообще никем не тестировались. Поэтому, как поведет себя 486-ядро в вашей системе – заранее неизвестно и выяснить это можно только экспериментально.

===== >>> врезка внутри ядра =====

Существуют ли теоретические обоснования почему i486-ядро увеличивает быстродействие компьютера? Да, существуют и хотя до сих пор не ясен конкретный вклад каждого из них, общая картина событий выглядит скорее тривиальной, чем удивительной.

Начнем с того, что поддержка многопроцессорности не проходит бесследно и налагает на архитектуру ядра определенный отпечаток, заставляя его решать те задачи, которые на однопроцессорных машинах просто не возникают. Взять хотя бы проблему когерентности, т. е. согласованности данных. Представьте себе, что произойдет, если один процессор обратиться к недостроенной структуре данных, конструируемой другим процессором. Чтобы этого избежать в каждый момент времени только один процессор может модифицировать данные, а остальные блокируются при помощи спинлуков (от английского spinlock – взаимоблокировка). В однопроцессорных системам спинлуки лишены смысла и должны заменяться на NOP'ы, однако, в Windows этого не происходит и большую часть отведенного ему процессорного времени ядро расходует именно на спинлуки! Хуже того! Алгоритмы, эффективно исполняющиеся на двух или даже четырех процессорах, далеко не всегда сохраняют свою эффективность на одном. Судя по всему, во времена 486-процессоров Microsoft поддерживала независимые линейки ядер, оптимизируя каждое из них по отдельности. Когда же аппаратные возможности персональных компьютеров возросли, она с облечением свела все ядра воедино. Дизассемблирование доказывает, что однопроцессорная версия ядра практически во всем повторяет многопроцессорную, и работает намного медленнее, чем могла бы.

Другой источник тормознутости – этот пресловутый PlugandPrayBob0000-00-00T00:00:00BИнтересно, многие ли знают эту шутку… Кое-кто наверняка сочтет ее опечаткой :)

Kris Kaspersky0000-00-00T00:00:00n2kя тоже так считал, когда столкнулся с ней в первый раз, но потом дошло ;)

. Древние ядра самостоятельно обслуживали шины, DMA и прочие системные устройства, за каждым из которых жестко закреплялось свое пространство адресов ввода-вывода, свой IRQ и свой канал DMA. Теперь же все значительно усложнилось и… затормозилось. Ядро абстрагировалось от конкретного оборудования и перешло на виртуальные шины, эмулируемые драйверами соответствующих устройств. Билли ухитрился испоганить все, включая схему обработки прерываний. Это раньше диспетчер знал все прерывания в лицо, а теперь он вынужден постоянно обращаться к базе данных, выясняя какой вектор какому устройству принадлежит (ведь системные ресурсы могут динамически переназначаться во время работы)!

Ключ /PCILOCK файла boot.ini запрещает системе использовать динамическую адресацию IO/IRQ на PCI-шине, что в некоторых случаях значительно повышает производительность, однако, препятствует совместному использованию системных ресурсов несколькими устройствами одновременно. Теоретически, BIOS и Ось должны равномерно распределять порты/прерывания между устройствами, однако, практически они нередко впадают в грубые ошибки, вешая на одно прерывание несколько устройств, даже когда свободные IRQ еще не исчерпаны.

{{overhal.hacker-edition_Image_2.png}}

Рисунок 3 компоненты ядра

Как уже говорилось ядро состоит из библиотеки аппаратных абстракций и исполнительной системы. Архитектурно, библиотека аппаратных абстракций включает в себя набор системно-зависимых функций, на которые опирается системно-независимое ядро, реализующее базовые сервисы операционной системы. При переносе оси на другую платформу фактически достаточно переписать один лишь HAL, не трогая все остальное. Это в теории. На практике же, во-первых, всякий перенос требует радикальной переделки всей системы, а, во-вторых, на сегодняшний день Windows 2000, XP и 2003 существуют всего лишь на одной платформе – платформе IBM PC и потому по ряду соображений HAL и исполнительная система тесно переплетены.

Конкретный перечь функций ядра здесь не приводится, т. к. он постоянно меняется от версии к версии и системные компоненты мигрируют из одной библиотеки в другую (раньше графический интерфейс был прикладной подсистемой, теперь это часть ядра, раньше шинами и ресурсами заведовал HAL, теперь эта функция возложена на исполнительную подсистему и ACPI, ну и т. д.). К тому же, это заняло бы слишком много места. Общее представление о ситуации дает рис .3, и никакой необходимости углубляться в его детализацию я не вижу.

===== >>> врезка что такое ACPI =====

Вопреки своей аббревиатуре, расшифровываемой как //**A**////dvanced////**C**////onfiguration////and////**P**////ower////**I**////nterface////,//**ACPI** означает нечто большее, нежели простой менеджер питания. Это еще и менеджер ресурсов, фактически являющийся //корневым////перечислителем//. В ACPI-системах все устройства (как-то PCI/ISA шины, жесткие диски, видео карты), подключены к виртуальной шине ACPI-контроллера (см. рис. 4), в чем легко убедиться если в меню "Вид" Диспетчера Устройств выбрать "Устройства по подключению", отобразив иерархию устройств (см. рис. 5). Первым делом Windows загружает ACPI-драйвер, опрашивающий ACPI-контроллер на предмет подключенных к нему устройств, главным из которых является PCI-шина (да! шина – это тоже устройство). Затем, загружает PCI-драйвер и, опрашивая PC-шину, обнаруживает новые устройства: платные расширений, прочие шины. Процесс повторяется до тех пор, пока не будут перечислены все имеющиеся устройства.

Физически ACPI-шины не существует (реально весь ввод/вывод идет через PCI/AGP) и все устройства в принципе доступны и напрямую. При смене ACPI-ядра на не-ACPI ядро так, собственно, и происходит. Однако, сведения о конфигурации оборудования, содержащиеся в реестре, оказываются недействительными, отчего система тихо едет крышей и отказывается загружаться, требуя переустановки.

Какие реальные выгоды дает ACPI-технология? Ну, во-первых, она полностью вытесняет PlugandPray, а вместе с ним и разборки между BIOS'ом и операционной системой по вопросам конфигурирования устройств. Теперь, этого не может делать ни операционная система, ни BIOS, и право конфигурирования полностью отходит к ACPI. Во-вторых, ACPI при необходимости может сохранять состояние всех устройств и оперативной памяти на жестком диске, восстанавливая его при последующем включении питания. Это не только многократно ускоряет загрузку Windows, но и возвращает систему в том виде, в котором она была до отключения, позволяя вам продолжить работу как будто бы никакого отключения вообще не происходило!. Для этого при завершении работы следует выбрать "ждущий режим" или нажать соответствующую кнопку на расширенной клавиатуре (обычно она выглядит в виде старого месяца). Режим ACPI естественно должен поддерживаться.

{{overhal.hacker-edition_Image_3.png}}

Рисунок 4 ACPI как корневой перечислитель

{{overhal.hacker-edition_Image_4.png}}

Рисунок 5 устройства, подключенные к виртуальной ACPI-шине

===== >>> врезка что такое APIC =====

**APIC** – //**A**////dvanced////**P**////rogrammable////**I**////nterrupt////**C**////ontroller//(Усовершенствованный Перепрограммируемый Контроллер Прерываний). Стандартный контролер прерываний, базирующийся на микросхеме Intel 8259A или ее аналогах((  (оригинальная микросхема использовалась только в AT, а ныне контроллер прерываний часть южного моста чипсета) )), поддерживает 8 линий прерываний и работает только в однопроцессорных системах. В IBM PC таких контроллеров всегда два, причем второй подключен на вход первого, в результате чего максимальное количество поддерживаемых прерываний увеличивается до 15. Мало? Усовершенствованный контроллер прерываний, которым оснащаются многопроцессорные системы, поддерживает до 256 прерываний, которых хватает сполна.

На программном уровне PIC и APIC взаимно совместимы, поэтому APIC-ядра способны работать и с PIC-контроллерами (по крайней мере теоретически). Практически же в некоторых конфигурациях наблюдаются более или мене тяжкие глюки, иногда исправляемые очередным ServicePack'ом, иногда нет. Естественно, APIC ядро само по себе новых линий прерываний не добавляет…

{{overhal.hacker-edition_Image_5.png}}

Рисунок 6 схематичная реализация APIC в двухпроцессорной системе

{{overhal.hacker-edition_Image_6.png}}

Рисунок 7 южный мост чипсета, содержащий контроллер APIC

===== заключение =====

Единого мнения по поводу целесообразности перехода на 486-ядро как не было, так и нет. Сообщения о реально проведенных экспериментах носят единичный характер и статистики по ним не постоишь. Bob0000-00-00T00:00:00BВот до этого момента заключение идет хорошо, но закончить хотелось бы без упоминания «разгона», а уж тем более  призыва «оставлять свои впечатления на сайте журнала». :) Просто надо предложить читателю поэксперементировать самому, пожелать успеху ни у типа того. 

Kris Kaspersky0000-00-00T00:00:00n2kОК, убрал разгон

Тем не менее, перепробовать различные ядра, сравнивая их на вкус, все-таки стоит. Это не только интересно, но еще и познавательно.


