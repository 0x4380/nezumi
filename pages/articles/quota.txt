====== quota ======
<sub>{{quota.odt|Original file}}</sub>

====== выживание в системах с жестоким квотированием ======

крис касперски аргентинский болотный бобер nezumielraton ака нутряк ибн мщъх, no-email

**время глобальных эпидемий давно прошло и сейчас большинство вирусов гибнет еще на излете, даже локальные вспышки удается зажечь лишь немногим. давайте попробуем разобраться почему, заодно обсудив новые вирусные концепции, адоптированные к суровым условиям современной жизни.**

===== введение =====

Проводя параллель между биологическими и компьютерными вирусами в основном обращают внимание на способность последних к размножению, но ведь мартовские коты тоже размножаются (да еще как размножаются!) но к вирусам их не относят, так что критерий размножения, бесспорно, необходимое, но недостаточное условие для правильной классификации, а сама аналогия неполная, однобокая и вообще идеологически неправильная.

Вирусы (настоящие вирусы) появились на ранней стадии эволюции в результате жесткой борьбы за хавчик и территорию обитания, то есть за существование. Чтобы не добывать хавчик самостоятельно (чего зря напрягаться), вирусы научились паразитировать на других существах. Кстати, о деструкции. Смерь организма-носителя вирусу крайне невыгодна, ведь вместе с носителем погибает и сам вирус. Двигаясь длинным эволюционным путем, вирусы и организмы неизбежно притирались и продолжают притираться друг к другу, в образуя различные формы симбиоза. Каждый из нас носит в себе кишечную палочку, можно даже сказать кишит ею и... ничего! Не умирает и не высаживается! Или вот другой пример. Сразу же после перестройки рэкетиры наезжали на "фирмачей" выгребая их подчистую, но позже они осознали главный тезис паразита: меньше возьмешь — больше получишь.

Внедрение вируса в файл внешне очень похоже на паразитирование, однако, это не так. Операционная система предоставляет практически неограниченные ресурсы и конкретной борьбы между программами просто не возникает! Внедрение вирусного кода в программу можно (и нужно!) рассматривать только как способ распространения. Тем же путем репейники "внедряются" в хвост Осла Иа-Иа, чтобы он перенес их на новое место, расширяя ареал обитания. Во времена MS-DOS, когда пользователи интенсивно обменивались исполняемыми файлами, таская дискеты от одного компьютера к другому, этот способ работал шикарно. Вирусоносные дискеты пересекали целые континенты, попадая из Африки в Советский Союз, а оттуда — в Соединенные Штаны. Или наоборот? Кто отследит все пути, кто теперь разберет?

С появлением Интернета ситуация изменилась. Пользователи прекратили пасти ослов, забыли что такое "винт в сумке" и перешли на централизованную раздачу с официального сервера по типу общепита. Некоторые личности (имена которых известны и так!) пророчили вирусам скорый конец и с нетерпением ждали светлого будущего, призрак которого уже маячил на горизонте.

Никто и не проложить не мог, что у будущего имеются свои собственные планы на этот счет, радикально расходящиеся в нашим! В досетевую эпоху дискеты были единственным способом распространения вирусов, но с появлением Интернета, вирусы получили возможность распространяться самостоятельно без дискет и Ослов. Рассылка исполняемых файлов почтой, отладочные люки в программах, предсказуемые пароли, переполняющиеся буфера… этот список можно продолжать бесконечно!

Необходимость паразитировать на других программах отпала. И хотя вирусы не перестали внедряться в посторонние файлы, цели, преследуемые ими, существенно изменились. Внедряются в основном для маскировки и сокрытия факта своего присутствия в системе. О захвате ресурсов речь пока не идет, но... кибернетический мир постоянно преображается, и современная ситуация уже совсем не та, что год или два тому назад.

Вплоть до появления W2K пользователи Windows даже не знали, что существует такая штука, называемая "квотированием" ресурсов. Каждый процесс получал в свое распоряжение 4 Гбайта адресного пространства (из которых реально можно было использовать только полтора) и все свободное пространство, которым только располагали смонтированные диски. Подсистема безопасности разграничивала доступ к файлам, запрещала вызывать некоторые API-функции и т. д., однако, никаких других ограничений не налагалось. Любой процесс, даже обладающий гостевыми правами, мог забить весь диск целиком, создать максимальное количество окон, сожрать всю оперативную память и единственное, что мог предпринять администратор — нажать RESET, надеясь на то, что неожиданная перезагрузка не превратит дисковый том в труху (NTFS хорошая вещь, но поддержка транзакций лишь уменьшает вероятность сбоя, но не гарантирует ничего).

В W2K (с большим опозданием против UNIX'а) наконец-то появилась поддеожка дисковых квот, определяющих максимальный размер доступного дискового пространства для каждого из пользователей, вслед за этим XP SP2 ограничила количество TCP/IP соединений в единицу времени для каждого из процессов, что по идее должно было предотвратить "заторы" в сети, вызванные вспышками вирусных эпидемий, а в настоящее время Microsoft бьется над созданием системы, загружающееся с Read-Only носителей (UNIX это умеет) и когда это будет сделано возможность модификации исполняемых файлов исчезнет (правда, вирусы по прежнему смогут внедряться в память и командные файлы, создаваемые администратором).

Возможности квотирования пока никем или практически никем не используются (многие администраторы о них даже не подозревают), но будущее не дремлет, надвигаясь на нас со всей своей неотвратимой тяжестью. Очередной конец вирусам? Или…

Наступает волнующий момент перерождения вирусов, когда в результате борьбы за существование они вынуждены научиться паразитировать на программах как это делают настоящие биологические вирусы, или сойти арены, пополнив свалку истории новыми строками кода.

===== каждому пользователю по квоте! =====

Механизмы квотирования, реализованные в Windows, затрагивают все аспекты жизнедеятельности системы и прежде, чем расчехлять свой хвост, это хозяйство надо как-то классифицировать. В первую группу попадают квоты, "привязанные" к отдельно взятому процессу, а точнее его PID. Система позволяет отслеживать (и ограничивать): общее время "жизни" процесса, количество затраченного процессорного времени (как на прикладном уровне, так и в режиме ядра), число операций ввода/вывода (т. е. прочитанных/записанных байт), объем затребованной (реально выделенной) памяти, и т. д. Остальные параметры можно узнать из "Диспетчера Задач". Жмем <Ctrl>+<Shit>+<Esc>, переходим к вкладке "процессы", в меню "вид" видим пункт "выбрать столбцы". нажимаем. их много будет там (см. рис. 1).

Любой программист за пару часов соорудит несложный монитор, выявляющий "подозрительную" активность процессов и, при необходимости, ограничивающий их аппетит. Пока еще NT не умеет квотировать память и объем ввода/вывода, но это несложно реализовать путем перехвата базовых native-API функций, чем уже занимаются некоторые антивирусные программы и персональные брандмауэры.

{{quota_Image_0.png}}

Рисунок 1 процессорные ресурсы, отслеживаемые NT (пока только отслеживаемые, еще не квотируемые)

Вместе с этим, Windows наконец-то начинает приобретать черты многопользовательской системы, что несет в себе как преимущества, так и угрозу (для существования вирусов). Кто-то может возвратить, что NT была многопользовательской с самого начала. Ну и в чем же это реально проявлялось? В каждый момент времени в системе может находится только один пользователь (запуск программ от имени другого пользователя не в счет) и прежде чем создать новый сеанс, предыдущий должен быть завершен. Хуже того! Пользователи не могут устанавливать приложения в "свои" домашние папки и многопользовательский доступ ограничивается одним лишь разграничением доступа к данным и индивидуальным настройками (каждому пользователю — свой HKEY_CURRENT_USER)! А вот в UNIX кто угодно может себе позволить установить свою собственную версию системных библиотек и программ, доступную только ему и никак не влияющую на остальную часть системы! Допустим, Маша хочет работать с Word 97, Ира — с Word 2000, а Марине подавай только Word XP. Что может сделать администратор?! Да ничего! Либо долго плясать с бубном, устанавливая утилиты от сторонних разработчиков, либо всерьез задуматься о том, сколько пользователей _реально_ может выдержать NT.

В XP уже появилась возможность быстрого переключения между несколькими сессиями, однако, до "промышленного" состояния ей еще расти и расти, однако, недалек тот день, когда один компьютер будет оккупирован толпой пользователей, вынужденных бороться за память и процессорные ресурсы. Впрочем, это происходит уже сейчас... Вместо того, чтобы приобретать отдельный компьютер сыну, жене и себе, любимому, некоторые путем установки относительно недорого оборудования подключают к одному компьютеру чуть ли не до пяти мониторов и еще столько же мышей и клавиатур, превращая свой PC в настоящий сервер, правда, если жена смотрит крепко пожатый видеофильм, сын рубиться в сильно трехмерную стелялку, то главе семейства остается только раскладывать пасьянс, или... квотировать ресурсы (особенно во время ответственной компиляции)!

Многие компании, предоставляющие услуги хостинга (или торгующие процессорным временем кластерной системы), активно используют механизмы квотирования, без которых данная затея лишена всякого смысла.

===== как размножаются ежики или как образуются зомби =====

Квоты, привязанные к PID'у, легко обойти. Достаточно периодически (например, один раз в минуту, или даже секунду!) порождать новый процесс, термируя предыдущий. Новорожденный процесс получает //полную// порцию свежей квоты, а когда она иссякает, трюк с "перерождением" повторяется вновь. Это очень древний прием, используемый самим Червь Морриса, но известный задолго до него. Конечно, подобная "активность" является ненормальным явлением, притягивающим внимание персональных брандмауэров и антивирусов, но этих простофиль легко обхитрить.

Свой запуск антивирус начинает с проверки памяти. Он получает список активных процессов, тщательно проверяя каждый из них на вшивость. Легальными средствами список процессов можно получить с помощью функций TOOLHELP32, экспортируемых библиотекой KERNEL32.DLL, которую перехватывают многие вирусы, не желающие быть замеченными. Сама по себе техника перехвата предельно тривиальна и к тому же описана в куче хакерских статей, так что не будем на ней останавливаться, тем более, что существует другой источник информации — недокументированная функция **NtQueryInformationProcess**, экспортируемая NTDLL.DLL, но фактически реализованная в NTOSKRNL.EXE и перехватить ее "прямой" вызов уже труднее. Без знания ассемблера и умения писать драйвера тут уже не обойтись, но, к счастью, существуют и другие пути, работающие на всех операционных системах и не требующие напряжения мозговых извилин.

{{quota_Image_1.png}}

Рисунок 2 для получение информации о процессах "диспетчер задач" использует недокументированную функцию NtQueryInformationProcess

Проведем простой эксперимент. Запустим FAR (если он только не был запущен ранее), нажмем <F11> и в списке плагинов найдем "Processlist", вываливающий список процессов в текущую панель.

{{quota_Image_2.png}}

Рисунок 3 специальный плагин позволяет FAR'у следить за процессами

Для получения более подробной информации о процессе, подводим к нему курсор и давим <F3> или <F4>, вот например:



Module:  CnxDslTb.exe

Full path:  C:\Program Files\ZyXEL\OMNI ADSL USB\CnxDslTb.exe

File version:  2.099.080.000

Description:  TaskBar Application

PID:  1076

Parent PID:  956  (Explorer.EXE)

Priority:  8

Threads:    4

Owner:  KPNC\kris kaspersky (S-1-5-21-73586283-2111687655-19574488-1000)

Session:  0

Started at:  23.03.2006 19:50:28

Uptime:  06:23:26

Processor Time:  00:00:24.243  0%

Privileged Time:  00:00:16.161  0%

User Time:  00:00:08.082  0%

Handle Count:    144

Page File Bytes:  2723840

Листинг 1 информация по конкретному процессу, полученная с помощью FAR (для экономии места приведен только крошечный фрагмент)

Ага, говорим мы голосом Тигры, неожиданно обнаружившего у себя под хвостом непочатую банку пива. Вотоно! Ass of the Dragon! Имя процесса, путь к исполняемому файлу, PID материнского процесса, время запуска и прочая информация перед глазами. Полный путь — это нехорошо. Любой пользователь (антивирус) может считать файл с диска и посмотреть, что это за зараза такая! Как бы его преодолеть? В смысле изменить истинный путь на что-нибудь другое? Увы! Легальными средствами с прикладного уровня до этой информации не дотянуться (как минимум, потребуется заполучить права администратора). В довершение ко всему, NT блокирует исполняемый файл вплоть до его завершения — команда DeleteFile возвращает error и идея создать временный файл, автоматически удаляющий себя после запуска, летит к черту.

И вот на сцене появляется мыщъх. Весь в сером. Стеснительно покусывая кончик хвоста, он говорит: NT блокирует только удаление и запись в файл, но допускает rename. Причем, может быть переименован не только сам файл, но и путь к нему, пускай и ценой побочных эффектов разной степени тяжести. Что это за эффекты такие? Давайте посмотрим! Создаем каталог "D:\1\2\3\", кладем в него notepad.exe (или любую другую программу по вкусу) и запускаем ее. Теперь, переименовываем "1" в... ну, например, в "a". Угадайте, что мы получим?

Наперекор всяким переименованиям каталог "D:\1\2\3\" как был, так и остался, но теперь он... пустой! Совсем пустой! Зато образовался каталог "D:\A\2\3\" с notepad'ом внутри. Здорово! Переименуем notepad.exe в xxx.exe. Как видим, он совсем не сопротивляется и успешно переименовывается. Аналогичным путем могут быть переименованы каталоги "2" и "3". Единственное, что мы не можем делать — это менять диск, но нам этого и не нужно! Главное, что запущенный из "D:\1\2\3\notepad.exe" файл переместился в "D:\a\2\3\xxx.exe", то есть поменял не только имя, но и место жительства. А что на счет списка процессов? Так вот, знайте, что NT создает его лишь однажды — в момент запуска процесса и никогда не обновляет.

То есть, в нашем случае, FAR (равно как и любая другая программа) "честно" показывает исходный путь, которого нет (уже).

Module:  NOTEPAD.EXE

Full path:  D:\1\2\3\NOTEPAD.EXE

PID:  664

Parent PID:  716  (Far.exe)

Priority:  8

Threads:  1

Листинг 2 система запоминает путь к исполняемому файлу только в момент его запуска и никогда больше не обновляет, посылая нас туда, где (возможно) уже ничего (интересного) нет.

Антивирус просто не сможет открыть файл "D:\1\2\3\NOTEPAD.EXE", потому что его уже нет! Как говориться, кто не успел, тот опоздал. Теоретически (и практически) антивирус может "подключиться" к процессу через его PID, но этому легко противостоять. Достаточно распотрошить любой хороший упаковщик типа Armadillo или eXtremeProtector — они сопротивляются этому вовсю! (Как вариант, можно положить на прежний путь безобидный файл с тем же самым именем — вот тогда доверчивый антивирус обломается по полной программе, даже не подозревая как круто мы его провели).

Резидентные мониторы таким образом обойти уже не получится. Они перехватывают API-функции, отвечающие за чтение файлов и запуск процессов (как правильно это CreateFile и CreateProcess), прогоняя программу через анализатор _до_ ее запуска. Несколько лет назад мыщъх опубликовал в хакере статью "//техника выживания в мутной воде или как обуть антивирус//" описывающую ряд элегантных и эффективных приемов, обламывающих антивирус со всеми его эвристическими анализаторами. Тогда было достаточно упаковать программу каким-нибудь навесным упаковщиком (неважно — известным антивирусу или нет) а в точку входа вставить jump на свой thunk, использующий самомодифицирующийся код, структурные исключения или новомодные SSE команды, после чего восстанавливающий оригинальное содержимое, затертое jump'ом и передающий распаковщику бразды правления. Но виртуальные машины антивирусных систем за последнее время значительно окрепли и часть этих трюков уже перестала работать, а скоро они перестанут работать совсем! Что же делать? Без паники парни! Не торопитесь высаживаться на измену, а лучше повращайте хвостом и подумайте головой.

Самое простое — воткнуть в thunk функцию SetTimer/Sleep, вызывающую оригинальную точку входа через несколько секунд. Ни один из известных мыщъх'у антивирусов не анализирует аргументы SetTimer и не ждет так долго. С его точки зрения программа выглядит так:

SetTimer(,,,);

Sleep(,);

Exit(,);

Листинг 3 таким антивирусу представляется защищенная программа

Сочетание команд, конечно, удивительное, но с точки зрения машинной логики вполне "законное". А еще можно использовать асинхронные вызовы процедур (APC), создаваемые API-функцией QueueUserAPC. Да много всякого можно придумать! Но мы ведь совсем не об этом говорим! Вернемся к нашим баранам, то есть процессам, точнее — к идентификаторам родительских процессов (parentPID). Это настоящая кладезь информации для антивирусов и продвинутых пользователей.

{{quota_Image_3.png}}

Рисунок 4 NTExplorer Мака Руссиновичка отображает иерархию процессов и выслеживает процессы-зомби (если они есть)

Возьмем к примеру утилиту tlist из комплекта Microsoft Support Tools и запустим ее с ключом "-t" (см. листинг 4), а еще лучше воспользуемся NT Explorer'ом Марка Руссиновичка, бесплатную копию которого можно скачать с http://www.sysinternals.com/Utilities/ProcessExplorer.html (см. рис. 4)

System Process (0)

System (8)

 SMSS.EXE (232)

 CSRSS.EXE (260)

 WINLOGON.EXE (280) NetDDE Agent

 SERVICES.EXE (308)

 svchost.exe (476)

 spoolsv.exe (504)

 svchost.exe (532)

 Smc.exe (604) Sygate Personal Firewall

 ups.exe (676)

 WinMgmt.exe (1392)

 LSASS.EXE (320)

explorer.exe (956) Program Manager

 pdesk.exe (1044) Matrox QuickDesk

 CnxDslTb.exe (1076) MCI command handling window

 HTTPProxy.exe (1104)

 internat.exe (1060)

 TASKMGR.EXE (1148) Диспетчерзадач Windows

 CMD.EXE (1188) sh

 WDM.exe (992) WarDaemonManager - [Daemon1]

 war-ftpd.exe (392) WarDnsResolverWnd

 lingvo32.exe (1280) Lingvo 5.0

 hh.exe (704) MSDN Library Visual Studio 6.0

 WarTrayIcon.exe (1240) WarTrayIcon

 winamp.exe (960) 10. 10.позорная-звезда - Winamp

 MSIMN.EXE (940) Входящие - Outlook Express

 thebat.exe (680) The Bat!

 Far.exe (716) tlist.exe -t > 1

 hh.exe (656) The Undocumented Functions - Microsoft Windows NT/2000

 NOTEPAD.EXE (664) Безымянный - Блокнот

 CMD.EXE (1408)

 tlist.exe (624)

 hh.exe (1288) Windows 2000

WINWORD.EXE (740) avp_silent.doc - Microsoft Word

Листинг 4 иерархияпроцессов, полученнаяутилитой tlist.exe изнабора Microsoft Support Tools

Иерархия процессов видна как на ладони! Сразу ясно кто кого породил и кто откуда. А если материнский процесс уже завершился и parentPID указывает в никуда? Тогда образуется процесс "зомби", сразу же привлекающий к себе внимание, особенно если этот процесс периодически порождает новых "зомби", а сам исчезает. Увы! Это ограничение данной техники! Рождение и смерть процессов — достаточно примечательные события, чтобы долго оставаться незамеченными, впрочем, как показывает практика, они все-таки таковыми и остаются, особенно если размножается по хитрому, выдерживая перед завершением процесса небольшую паузу. Тогда в системе будут постоянно присутствовать ровно два зомби с одинаковыми именами (впрочем, путем перекрестного "опыления" можно создать два разноименных зобми, попеременно вызывающих друг друга), с постоянно изменяющимися PID'ми. Но не все пользователи обращают внимание на PID'ы. Главное, чтобы костюмчик сидел (а он сидит).

В процессе практической реализации этой схемы программист неизбежно сталкивается с проблемой передачи данных от одного процесса к другому. Как ее осуществить? Существует очень изящный трюк, позволяющий прерывать выполнение процесса в любое время (например, при антивирусной угрозе), возобновляя работу порожденного зомби с того же самого места. Это просто! Все перемененные процесса хранятся в разделяемой области памяти, туда же перед завершением записывается и регистровый контекст (чтение контекста осуществятся функцией GetThreadContext, а запись SetThreadContext, естественно контекст каждого потока должен сохраняться отдельно). Порожденный процесс считывает контекст своего предка из сохраненной области памяти, устанавливает его вручную с помощью несложной ассемблерной вставки (именно вручную!!! функция SetThreadContext корректно работает только с "замороженными" потоками, а создавать дополнительный поток только для того, чтобы восстановить контекст основного потока, нам откровенно в лом, тоже самое можно сказать и о сохранении контекста, впрочем... на вкус и цвет любителей нет).

Таким образом, с точки зрения хакера, разрабатывающего злобный вирус, нет никакой разницы сколько процессов участвует в схеме. Переключение происходит совершенно "прозрачно" и, если в довершение ко всему процесс-потомок наследует дескрипторы всех объектов своего родителя, программа выполняется как будто бы никаких переключений не происходит, вот только квоты постоянно обновляются, подкидывая свежие охапки дров в пылающий огонь!

===== захват чужих ресурсов =====

Вот мы и подошли к паразитам вплотную. Вместо того, чтобы плодить зомби, рискуя быть обнаруженным и создавая никому ненужную активность, напрягающую систему, не лучше ли тайком внедриться в чужую программу, используя ее ресурсы как свои собственные? Великолепная идея, вот только... любой известный механизм внедрения легко распознается антивирусами и персональными брандмауэрами. И нам, чтобы выжить, необходимо предложить радикально новый способ, который не удастся проконтролировать никому.

Большинство вирусов внедряет свой код посредством функции WriteProcessMemory, которую контролируют всякие сторожа. А как они могут ее контролировать? Обычно используется тривиальный примем: правится (в памяти) таблица экспорта KERNEL32.DLL так, чтобы WriteProcessMemory указывал на антивирусную насадку, проверяющую кто и зачем эту функцию вызывает. В других случаях правится непосредственно сам код функции WriteProcessMemory (например, в ее начало ставиться jump на антивирусный thunk). Короче, вызывать WriteProcessMemory может только самоубийца, тем более, что WriteProcessMemory это только "обертка" вокруг ZwProtectVirtualMemory, экспортируемой NTDLL.DLL, которую контролирует значительное меньшее количество антивирусов/брандмауэров.

{{quota_Image_4.png}}

Рисунок 5 функция WriteProcessMemory в действительности представляет собой "обертку" вокруг ZwProtectVirtualMemory

В свою очередь, ZwProtectVirtualMemory обращается непосредственно ядру операционной системы через прерывание int 24h со значением 77h в регистре EAX (начиная с XP интерфейс взаимодействия с ядром осуществляется через специальную машинную команду systenter, но прерывание INT 2Eh по-прежнему поддерживается и работает в целях сохранения обратной совместимости).



.text:77F82C30 ZwProtectVirtualMemory proc near; CODE XREF: sub_77F81C0C+10E↑p

.text:77F82C30; sub_77F8DFB8+85↓p ...

.text:77F82C30

.text:77F82C30 arg_0= dword ptr  4

.text:77F82C30

.text:77F82C30moveax, 77h; NtProtectVirtualMemory

.text:77F82C35leaedx, [esp+arg_0]

.text:77F82C39int2Eh

.text:77F82C3Bretn14h

.text:77F82C3B ZwProtectVirtualMemory endp

Листинг 5 реализация функция ZwProtectVirualMemory – это самая низкоуровневая функция прикладного уровня, ниже которой находится только ядро

Очень немногие сторожевые программы работают на таком низком уровне, поэтому мы имеем хорошие шансы остаться незамеченными, однако... риск все-таки есть. Что поделаешь —такова специфика нашей профессии. Но глубже спускаться уже некуда! Ниже только ядро! Нет, можно конечно, написать драйвер, разбирающий каталог страниц, и внедряющий код напрямую в физическую память или сделать тоже самое с прикладного уровня, обратившись к псевдоустройству "\\Device\\PhysicalMemory", которое вплоть до Windows 2003 Server SP1 было доступно администратору на чтение/запись, но теперь работать с ним не может даже System, отбрасывая нас назад к драйверу (см. статью "Changes to Functionality in Microsoft Windows Server 2003 Service Pack 1 Device\PhysicalMemory Object" насайте Microsoft: www.microsoft.com/technet/prodtechnol/windowsserver2003/library/BookofSP1/e0f862a3-cf16-4a48-bea5-f2004d12ce35.mspx). Другая сумасшедшая идея — спуститься на секторный уровень (SPTI/ASPI интерфейсы вам в помощь), забраться в файл подкачки и слегка "подправить" программу. Но ведь это же бред!

Существуют гораздо более элегантные и незаметные способы безопасного внедрения! Нам ведь все равно в какую программу внедряться, правда? Мы же ведь не вендетту устраивать собирается! Мы чужие ресурсы ограбить хотим. А лучший способ грабежа — охота на лопуха. Многие программы поддерживают плагины и другие виды расширений. Достаточно забросить модуль в определенную директорию или слегка подправить конфигурационный файл (реестр). Программа загрузит наш плагин как родной и мы окажется в чужом адресном пространстве в пределах которого можно делать все, что угодно.

Вот только IE не трогайте, ладно? Он со свитой своих расширений находиться под пристальным вниманием целой армии сторожей. Другие программы в этом отношении более простодушны и лояльны. Взять хотя бы FAR, которым пользуется всякий и каждый. Плагины хранятся в каталоге Plugins и автоматически загружаются при запуске, не требуя ни подтверждения пользователя, ни цифровой подписи, словом ничего такого, что хакеру могло бы помешать. Какой смыл проникать в FAR? ну, во-первых, FAR очень могучая программа. У многих пользователей на Рабочем Столе находится ярлык, запускающий FAR с правами администратора (если же такого ярлыка нет, FAR запускается из сеанса "администратора", какое же администрирование без FAR'a!). А это значит, что проникнув в FAR, мы рвем банк. Что такое "права администратора" в умелых хакерских руках, надеюсь, не надо объяснять? Это каюк всем антивирусам! Это возможность загрузки любых драйверов, переводящих борьбу в плоскость нулевого кольца, где побеждает умнейший ;) Во-вторых, процессы, порожденные FAR'ом, выглядят вполне адекватно и естественно. Пользователь, даже при возникновении каких бы то ни было подозрений, будет думать, что это он сам их запустил, своими руками. В-третьих... опять-таки ресурсы. Даже в системе с квотированием, FAR'у будут установлены могучие привилегии, иначе как с ним работать?!

{{quota_Image_5.png}}

Рисунок 6 FAR хранит свои макросы в реестре, куда открыт доступ каждой программе

Другим могучее орудие пролетариата — макросы. FAR хранит их в реестре и позволяет переназначить любую комбинацию клавиш, даже уже занятую. В дополнении к этому, он позволяет макросам подавлять вывод на экран. Что это значит? А вот что! Возьмем комбинацию, которая используется как можно чаще (например, <Alt>+<F1>, отвечающая за выбор диска в левой панели) и повесим на нее последовательность э… некоторых "полезных" действий (не обязательно деструктивных), а после этого нажмем <Alt>+<F1> для вызова настоящей панели, чтобы у пользователя не возникало никаких подозрений, что здесь что-то не так. Поскольку, FAR предоставляет доступ ко всем командам командной строки, возможности макро-вирусов оказываются поистине //**безграничны**//! Причем, обнаружить присутствие посторонних макросов очень сложно, разве только специально их искать, но для этого потребуется установить дополнительный плагин, отображающий макрокоманды в "естественном" виде, иначе в них сам мыщъх хвост оторвет.

А знаменитый Лис? Да это целое кладбище для хакеров готического типа! Бери и хакерствуй, в смысле устанавливай свои собственные расширения. Формально, "левые" расширения легко обнаружить, просто просмотрев перечь уже установленных, однако, далеко не всякий пользователь с уверенностью сможет сказать какие расширения он устанавливал и когда. Последние версии Оперы так же поддерживает расширения в виде мини-приложений, которые опять-таки никем не контролируются и не известно будут ли контролироваться вообще!

===== заключение =====

Забудьте о "классических" методах заражения исполняемых файлов и внедрения в процессы посредством VirtualAllocEx/WriteProcessMemory/CreateRemoteThread. Все это — наследие вчерашнего дня. Противостояние щита и меча сошлось в точке пересечения двух прямых — женских ног, где находится орган широко известный в народе под именем… Впрочем, обойдемся без именем. Вот этим самым органом это противостояние и накрылось. Методики внедрения отработаны до совершенства, а толку нет, потому что методики противостояния отработаны ничуть не хуже.

Оторвите глаза от клавиатуры и устремите свой взор в в будущее! (Нет, монитор, к будущему не относится). Ищите тропы, по которым еще никто не ходил! Мир открывает столько всяких возможностей, что зацикливаться на одних и тех же концепциях просто глупо. Программное обеспечение намного более уязвимо, чем это принято считать, но ой как не просто окинуть его свежим незамыленным взглядом. Великие идеи всегда рождаются неожиданно, они витают в воздухе, пока кто-нибудь не ухватит их, после чего все остальные дружной гурьбой бросаются их повторять. Идиоты! Это все равно что грабить уже ограбленный банк, где уже вовсю орудует полиция. Забавнее всего то, что каждое такое ограбление, стягивающее к себе максимум службы правопорядка, заметно ослабляет охрану остальных объектов (и это, в общем-то, логично).

Чтобы победить в информационной войне, необходимо найти наименее охраняемый объект, привлекающий минимум внимания: о котором не пишут в книгах, не судачат на форумах, короче вообще не говорят. Пусть даже это им окажется захудалая сберкасса или сельпо. Главное ведь не нажиться! Главное — как следует окопаться, ударив оттуда, откуда никто не ждет. Вдали от линии фронта, в партизанской войне всегда выигрывают партизаны, поскольку к каждому сарайчику часового не приставишь. А вот на линии фронта расстановка сил зависит только от финансовой мощи соперников. Вирусы бьются влет только потому, что в антивирусной индустрии замешаны большие деньги. Очень большие, можно сказать даже "бешенные". Но все они сосредоточены в нескольких узких секторах "перспективных" направлений, а это значит, что простор для творческих маневров у хакеров все-таки есть и всегда будет!


