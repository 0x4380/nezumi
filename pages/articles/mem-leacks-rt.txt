====== охота и рыбалка в динамической памяти\\ tagline: борьба с утечками ресурсов в реальном\\ времени без перекомпиляции приложений ======
<sub>{{mem-leacks-RT.odt|Original file}}</sub>

крис касперски ака мыщъх, a.k.a. nezumi, a.k.a souriz, no-email

**памяти свойственно утекать, образовывая мощные осадочные пласты в адресном пространстве, которые уже никогда-никогда не вернулся обратно в общий пул, а потому сколько бы виртуальной памяти у нас ни было — рано или поздно она таки заканчивается, что особенно актуально для серверов и рабочих станций, пилотируемых в круглосуточном режиме без ежедневных перезагрузок. и хотя разработчики периодически исправляют ошибки, реальной помощь от них ждать не приходится и мы остаемся со своими проблемам один на один...**

{{INLINETOC}}
===== введение =====

Большинство статей, посвященных проблемам утечек ресурсов, ориентированы главным образом на программистов, имеющих в своем распоряжении исходные коды и обширный набор различных диагностических утилит от штатных отладчиков, входящих в комплект поставки компилятора, до специализированных анализаторов типа **IBM ****Rational****Purify**, **BoundsChecker** или **Valgrind**.

Работа с исполняемыми модулями уже откомпилированных программ в лучшем случае поддерживается в очень ограниченном режиме (а зачастую не поддерживается вообще), но, как бы там ни было, даже обнаружив место утечки, исправить ее непосредственно в машинном коде может только продвинутый хакер (сколько времени он проведет за отладчиком, история умалчивает и кто оплатит его работу — остается только гадать).

Мы же люди простые. Администраторы мелко-корпоративных, офисных или даже домашних серверов, как правило, работающих на основе NT-based систем. Исходных текстов у нас нет, да и времени/средств на исправление _чужих_ ошибок тоже. Тем не менее, бороться с утечками все же приходится. Кому не случалось перегружать зависший сервер, не реагирующий даже на ALT-CTRL-DEL, и давить на RESET с угрозой разрушения дискового тома и потери кучи оперативных данных?

На самом деле, чтобы справиться с утечками (или, по крайней мере, минимизировать возможные убытки) совершенно необязательно быть хакером и владеть исходными текстами. Более того, борьба (включая превентивные мероприятия) практически не отнимает времени и потому может быть взята на вооружение любым администратором, даже самым начинающим.

{{mem-leacks-rt_Image_0.jpg}}

**Рисунок 1 куда утекает память… кладбище потерянных ресурсов**

===== классификация утечек и причины их возникновения =====

Прежде, чем бороться с утечками, необходимо разобраться: что это вообще такое и потому они происходят. Куда утекает память? Риторический вопрос! Да никуда она не утекает, это просто термин неудачный такой. Правильнее говорить об "отложении" или "пластовании" ресурсов по аналогии с осадочными слоями.

Рассмотрим следующий (вполне классический) пример:

<code c>
foo(char *x)
{
	// выделяем буфер из динамической памяти (так же называемой кучей)
	char *p = malloc(MAX_SIZE);
	
	// если строка не влазит в буфер - возвращаемся из функции
	if (strlen(x) >= MAX_SIZE) return ERR_STR_TOO_LONG;
	
	strcpy(p,x);		// копируем строку в буфер
	
	// делаем с ней что-нибудь полезное
	…
	…
	…
	
	// нормальный выход из функции
	free(p);		// освобождаем выделенную память
	return OK;		// возвращение без ошибок
}
</code>

**Листинг 1 фрагмент исходного кода, демонстрирующего утечку памяти**

Программист выделяет буфер под копируемую строку и, прежде чем начать копирование, заботливо проверяет ее длину. Если строка не помещается в буфер, происходит немедленный возврат из функции с сообщением об ошибке, но! выделенная память не освобождается! и не освободится никогда! Лишь при завершении процесса, система автоматически освободит все, что к тому времени он успел понавыделять. Учитывая, что серверные приложения не перезапускаются месяцами (и даже годами), становится ясно: утечки представляют собой едва ли не основную проблему и даже потеря одного байта в долговременной перспективе выливается в сотни мегабайт "осадочной" памяти.

При этом от разработчиков серверов автору постоянно приходится слышать, что мол, проблема утечек — фундаментальна и что если сервер теряет не более 1 Кбайта памяти в секунду — это вполне нормально. Количество установленной физической памяти не играет никакой роли и падение производительности за счет утечек практически полностью нивелируется тем фактом, что операционная система вытесняет неиспользованные страницы на диск в файл подкачки. Однако, адресное пространство процесса не безгранично и на 32-битных платформах по умолчанию составляет чуть менее 2 Гигабайт (остальные 2 Гбайта занимает ядро операционной системы, ядерные структуры данных, драйвера и т.д.).

Легко рассчитать, что если память утекает со скоростью 1 Кбайт в секунду, то адресное пространство будет полностью исчерпано за 25 дней, а на самом намного раньше, т. к. помимо динамической памяти в обозначенные 2 Гигабайта входит стек, образы исполняемых файлов и библиотек, структуры данных операционной системы прикладного режима и т. д. Для рабочей станции работать в течении месяца без перезагрузок — слегка противоестественно, а вот для серверов — это вполне нормальное состояние, но чтобы они не грохнулись раньше времени, необходимо преодолеть утечки.

Утечки делятся на две категории: **жесткие** (**hard**) и //мягкие// (//soft//). Мягкие утечки (так же называемые локальными) действуют только в течении некоторого периода времени, а затем возвращают "награбленные" ресурсы в общий пул. Вот, например, некоторый сервер, обрабатывает запросы пользователей в отельном потоке и под каждый запрос выделяет определенное количество памяти, но не освобождает ее после завершения обработки запроса, однако, при отключении клиента, вся память освобождается одним махом — вот это и называется локальной утечкой.

Жесткие (или глобальные) утечки не освобождаются плоть до того, пока администратор не отправит сервер в shutdown или не перезагрузит операционную систему. Последний момент очень важен! Если приложение выделяет блоки совместно используемой памяти (shared memory), то они не освобождаются вместе с завершением выделившего их процесса и продолжают болтаться в адресном пространстве вплоть до полной перезагрузки.

Кстати, помимо утечек памяти, существует проблема утечки и прочих системных ресурсов, например, файловых дескрипторов, количество которых хоть и велико, но все же конечно. Если сервер открывает файлы, забывая их закрыть, то в какой-то момент система просто рухнет, будучи не в силах открыть файл даже для сугубо своих системных нужд.

{{mem-leacks-rt_Image_1.png}}

**Рисунок 2 пример локальной утечки памяти**

===== утечка ресурсов как направленная атака =====

Приложение может работать годами, не вызывая никаких проблем и вдруг… с некоторого момента администратора начинают доставать непрекращающиеся утечки. Но ведь машинный код в отличии от фрегата (или другого судна) не может "прохудится" от старости!!!

Все дело в том, что существует малоизвестный подкласс DoS-атак, вызывающих отказ в обслуживании путем генерации запросов, приводящих к утечкам памяти. Вернемся к листингу 1. Допустим, что процедура foo обрабатывает поля некоторого заголовка, причем длина строки MAX_SIZE выбрана программистом с большим запасом, так, что нормальные запросы обрабатываются без каких либо проблем. Но вот коварные хакеры находят ошибку в коде и начинают бомбардировать сервер строками нечленораздельной длинны. И хотя это не приводит к немедленному отказу, количество свободной памяти постепенно уменьшается и уменьшается… вплоть до полного исчерпания кучи.

К сожалению, разработчики и специалисты по безопасности склонны недооценивать данный подкласс атак, поскольку ни к захвату управления, ни к утрате конфиденциальности, он не приводит, а потому заплатки под известные дыры зачастую вообще не выпускаются!!!

Можно ли справится с такими атаками самостоятельно? Имея хороший брандмауэр с гибкой системой фильтрации просто добавляем новое правило, отсекающее определенные запросы со строками чрезмерной длины (естественно, чтобы разобраться в ситуации потребуется тщательно проанализировать логи, а иначе никак!).

===== схватка с утечками врукопашную =====

Залогом успешной борьбы с утечками становится заблаговременная подготовка. Прежде всего до максимума увеличьте объем виртуальной памяти, не забывая о том, что если стартовый объем файла подкачки меньше конечного, до при достижении пороговой величины система попытается увеличить размер файл подкачки (если дискового места хватит), причем все запросы на выделение памяти в это время будут отклоняться и приложение вместо валидного указателя получит ноль, а вот как оно отреагирует на это – сказать неизвестно. Часть приложений завершат свою работу в аварийном режиме (с потерей не сохраненных данных), часть поведут себя неадекватно, выдавая порою очень странный результат. Так что лучше не мелочиться, не жертвовать дисковым пространством, а выделять, так выделять!!!

А сколько выделять-то?! Допустим, у нас есть k серверных приложений, порождающие n процессов (их легко посчитать в диспетчере задач), поскольку на 32х битных платформах каждый процесс владеет 4 Гигабайтами оперативной памяти. Тогда нам потребуется 4*(MAX(k, n) Гбайт памяти плюс еще пару гигабайт на системные нужды. Однако, при изменении размера файла подкачки через графический интерфейс (Мой Компьютер/Свойства Системы/Дополнительно/Параметры быстродействия/Виртуальная память/Изменить) мы ограничены 4х разрядным полем в мегабайтах, т. е. не можем получить более 10 Гбайт виртуальной памяти, чего, для большинства нужд вполне достаточно (и даже более чем достаточно), однако, для компьютеров на которых установлена куча серверных приложений, к которым никто не подходит месяцами, может потребоваться и больший объем, установить который поможем бесплатная утилита pagefileconfig.vbs: http://www.windowsfaq.ru/content/view/116/57/.

{{mem-leacks-rt_Image_2.png}}

**Рисунок 3 здесь можно взять утилиту для изменения размеров файла подкачки через командную строку**

Однако, независимо от количества имеющейся виртуальной памяти, каждый процесс получает в свое расположении чуть меньше 2 Гбайт кучи, которых при интенсивных утечках хватает совсем ненадолго. А потом — бац! И сервер в дауне. Иди, поднимай его потом…

Следующие операционные системы Windows XP Professional, NT Server 4.0 Enterprise Edition, W2K Advanced Server, W2K Datacenter Server, Server 2003/Enterprise Edition/Datacenter Edition поддерживают специальный ключ "/3G" в файле boot.ini, ужимающий систему до одного гигабайта и выделяющий высвободившееся место в личное пользование каждого процесса, то есть размер кучи возрастает до 3 Гигабайт (ну или чуть меньше за счет стека, образа исполняемого файла и динамических библиотек).

Подробнее об этом можно прочитать на http://support.microsoft.com/kb/823440, а ниже приводится пример готового Boot.ini файла, приготовленного по данной технологии:

<code>
[Boot Loader]
Timeout=30 
Default=multi(0)disk(0)rdisk(0)partition(2)\WINNT 

[Operating Systems] 
 multi(0)disk(0)rdisk(0)partition(2)\WINNT="Microsoft Windows Server 2003" /3GB
</code>

**Листинг 2 файл boot.ini, расширяющий размер кучи до 3 Гигабайт**

===== перезагрузка приложений =====

Если планируется использовать сервер длительное время в полностью автономном режиме (например, вы уезжаете в отпуск, оставляя домашний компьютер с ftp-архивом, предоставленным самому себе), то здесь потребуется намного более радикальные меры борьбы с утечками. А именно — периодический перезапуск серверных приложений командой kill.exe (входит в бесплатно распространяемый набор Microsoft Debugging Tools, Support Tools, а так же в Microsoft Platform SDK), закинутый в системный планировщик (см. описание штатной команды "at").

Кстати говоря, многие сервера имеют свои собственные встроенные планировщики, позволяющие делать мягкий shutdown при котором блокируется подключение новых клиентов, и в момент когда "отвалится" последний из имеющихся, сервер делает себе харакири, тьфу, то есть reboot.

{{mem-leacks-rt_Image_3.png}}

**Рисунок 4 все эти датчики бесполезны, если на них некотому смотреть**

Со серверами, реализованными как системные службы, в некотором смысле дела обстоят намного лучше, поскольку всякая служба обязана (по условиям спецификации) поддерживать "мягкую" перезагрузку без потерь оперативных данных, однако, далеко не всякая мягкая перезагрузка возвращает "осадочную" память, к тому же, источником утечек вполне может оказаться и головной процесс SERVICES.EXE, под котором все службы и "крышуются" (см. листинг 3). Попытка "убийства" SERVICES.EXE либо заканчивается сообщением о невозможности совершения такой операции, либо (если же все-таки увенчается успехом) система тут же рушится. Да… Ситуация…

<code>
System Process (0)
System (8)
  SMSS.EXE (232)
    CSRSS.EXE (260)
    WINLOGON.EXE (280) NetDDE Agent
      SERVICES.EXE (308)
        svchost.exe (480)
          DLLHOST.EXE (1048)
        Smc.exe (504) Sygate Personal Firewall
        ups.exe (536)
        svchost.exe (568) MCI command handling window
        vmware-authd.ex (1240)
          vmware-vmx.exe (1656)
        WinMgmt.exe (396)
      LSASS.EXE (320)
explorer.exe (748) Program Manager
  pdesk.exe (836) Matrox QuickDesk
  CnxDslTb.exe (872) MCI command handling window
  HTTPProxy.exe (880)
  internat.exe (888)
  TASKMGR.EXE (952) -испетчер задач Windows
  CMD.EXE (960) sh
    MULTILEX.EXE (1112) Multilex
    cmd-69.exe (1028) iастаманские народнvе сказки :: Tказки
</code>

**Листинг 3 процесс SERVICES.EXE выступает "крышей" для многих служб**

Вопрос из зала. А с какой частотой следует перегружать серверные процессы или даже саму операционную систему целиком, если перезагрузка данного процесса невозможна? Ответ, чтобы не привязаться к конкретному расписанию, будем периодически вызывать API-функцию VirtualQueryEx, возвращающую размер виртуальной памяти, потребляемый каждым процессорм и, как только он достигнет определенного порогового значения, выбранного нами заранее, уходит в reboot (естественно, для этого необходимо уметь хоть немного программировать).

Функция VirtualQueryEx принимает на грудь дескриптор процесса и возвращает следующие данные:

<code c>
typedef struct _MEMORY_BASIC_INFORMATION { // mbi 
	PVOID BaseAddress;		// базовый адрес региона
	PVOID AllocationBase;		// базовый адрес выделенного блока памяти
	DWORD AllocationProtect;	// "первородные" атрибуты защиты
	DWORD RegionSize;		// размер региона в байтах
	DWORD State;			// тип региона (выделен, закреплен, свободен
	DWORD Protect;			// текущие атрибуты защиты
	DWORD Type;			// тип страниц памяти
} MEMORY_BASIC_INFORMATION;
</code>

**Листинг 4 информация, возвращенная функцией VirtualQueryEx**

Вызывая ее многократно с различными базовыми адресами, мы, в конечном счете, получим полную картину адресного пространства, позволяющую нам принять решение о перезагрузке, когда свободных блоков практически не останется (тут, кстати говоря, необходимо учесть, что даже если мы имеем сто несмежных свободных блоков по 4 Кбайта, а программа прости каких-то жалких 10 Кбайт, запрос на выделение памяти не может быть выполнен в силу фрагментации кучи, а потому суммарный размер свободных блоков еще ни о чем не говорит!)

Детали реализации, мы оставим в стороне. В самом деле, это совсем несложная утилита, которую легко написать менее чем за вечер, однако, она необыкновенно эффективно в "разруливании" автопилотируемых серверов.

===== принудительное освобождение памяти =====

А вот не хотим мы перезапускать ни серверное приложение, ни саму операционную систему в целом. Ну вот не хотим и все!!! Тогда что?! Вот тогда-то и нам и пригодится весьма продвинутая методика, дающая неплохой результат, хотя и без всяких гарантий. Анализ большого количества программ, страдающих хроническими утечками памяти, показал, что указатели на блоки динамической памяти, как правило, (хотя и не всегда) помещаются в локальные стековые переменные, автоматически уничтожаемые компилятором при выходе из функции. Следовательно, если на данный блок динамической памяти не ссылаются ни другие блоки, ни локальные переменные, то его с высокой степенью можно считать "потерянным" и с некоторым риском освободить, возвращая память обратно в кучу.

Подобный "сборщик мусора" представляет собой довольно сложную программу, вынужденную учитывать многие нюансы, перечисление которых тянет на отдельный монументальный труд. У мыщъх'а пока что имеется pre-alpha версия, предназначенная сугубо для внутреннего использования.

Как она работает? Вместо того, чтобы определять границы стека каждого из потоков, мыщъх просто сканирует адресное пространство процесса (естественно, исключая невыделенные блоки), "выцеживая" 32-битные значения, похожие на указатели. "Похожие", значит, находящиеся в пределах динамических блоков памяти, полный перечень которых можно получить посредством следующих API-функций: CreateToolhelp32Snapshot\Heap32First\ Heap32ListFirst\Heap32ListNext\Heap32Next.

Занятые блоки динамической памяти, в границах которых нет ни одного указателя, считаются "осадочными" и освобождаются… А вот как они освобождаются — это уже вопрос. Можно, конечно, вызывать API-Функцию VirtualFreeEx и дело с хвостом, но! Компиляторы работают с динамической памятью не напрямую, а посредством своих собственных библиотек времени исполнения (Runtime Library или, сокращенно, RTL). Всякая работа с динамической памятью в обход RTL-менеджера приводит к неопределенному поведению и приложение обычно кончает свою жизнь крахом. Поэтому, мы должны "выпрыснуть" свой код в подопытный процесс и вызывать RTL-функцию освобождения памяти. Например, в языке Си это функция free().

Имеются, естественно, и другие трудности, но их обсуждение далеко выходит за рамки данной статьи. Главное, что освобождение "потерянной" памяти все-таки возможно!!!

{{mem-leacks-rt_Image_4.png}}

**Рисунок 5 принудительное освобождение "утекшей" памяти мыщъх'иной утилитой**

===== заключение =====

Мыщъх предложил несколько достаточно эффективных методов борьбы с утечками памяти, опробованными как на собственной шкуре, так и на ряде мелких предприятий. И хотя до "промышленного" внедрения данных методик еще далеко, они работают!!! И мыщъх продолжает рыть землю в этом направлении, разрабатывая полностью автоматизированный сборщик мусора, ориентированный на откомпилированные программы без исходных текстов, написанные на языке Си/Си++. Все желание принять участие в проекте всячески приветствуются (особенно, это касается специалистов по DELPHI, C# и т.д.).

Короче, дорогу осилит идущий!

{{mem-leacks-rt_Image_5.jpg}}

**Рисунок 6 хороший сервер должен работать как часы**


