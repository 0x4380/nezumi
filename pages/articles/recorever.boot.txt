====== recorever.boot ======
<sub>{{recorever.boot.odt|Original file}}</sub>

====== восстановление данных на NTFS разделах ======

крис касперски

**эта статья открывает цикл публикаций, посвященный ручному восстановлению данных на ****NTFS****-дисках без использования автоматизированных "докторов", зачастую только добивающих "пациента" вместо его лечения. мы коснемся всех аспектов проблемы – логические и физические дефекты, жесткие диски и съемные носители (****CD****-****ROM****, ZIP, магнитооптика, ****FLASH****…), программные и аппаратные ****RAID****-массивы и т. д. сегодня мы рассмотрим основные концепции хранения и организации данных на жестких дисках и поговорим о восстановлении загрузочных областей (таблицы разделов, ****boot****-секторов) на обычных и динамических разделах.**

===== введение =====

Долгое время главным козырем противников NTFS был следующий аргумент – чем вы будете ее восстанавливать, если она умрет? А мрет она, как показывает практика, достаточно часто. При всей своей надежности, NTFS не застрахована от потрясений. Ошибки оператора, вирусы, сбои питания, зависания ОС, дефекты поверхности, отказ электроники… С каждым днем человечество все сильнее и сильнее становится зависимо от компьютеров, объемы жестких дисков стремительно растут, а вместе с тем растет и ценность содержащихся на них данных, потеря которых зачастую невосполнима.

Спрос рождает предложение и на рынке как грибы после дождя вылупляются фирмы, специализирующиеся на восстановлении данных, однако, по-настоящему хороших специалистов можно встретить только в двух, ну от силы в трех из них, а все остальные лишь создают видимость кипучей деятельности, выставляя астрономические счета при довольно посредственном качестве восстановления. Но время кустарей уже ушло. Рабочая атмосфера изменилась. Хакеры разобрались со строением NTFS и документировали ее ключевые структуры. Начал формироваться достойный инструментарий для ручного восстановления. Наконец, за минувшее время накопился огромный опыт по борьбе за спасение данных, частью которого автор и хочет поделиться с читателями.

===== если вдруг случился сбой и данные оказались утеряны… =====

Прежде всего – не паникуйте! Заниматься восстановлением можно только на трезвую голову. Непродуманные, лихорадочные действия только усугубляют ваше и без того незавидное положение!

Не используйте никаких автоматизированных "лечилок", если полностью в них не уверенны. Последствия такого лечения могут быть катастрофическими, а результаты "восстановления" – необратимыми. То же самое относится и к "специалистам", обитающим в фирмах непонятного происхождения и орудующих все теми же автоматизированными утилитами, которыми вы можете воспользоваться и без них. Некоторые пытаются создавать необходимый инструментарий самостоятельно. Чаще всего он оказывается неработоспособным еще с рождения, но зато какая гордость для фирмы! Какое впечатляющее средство демонстрации собственной крутизны! Поверьте, утилиты типа Easy Recovery и Get Data Back далеко не дураки писали (да еще и при участии непосредственных разработчиков оригинального драйвера NTFS, хорошо знающих все его тонкости и особенности поведения). Это лучшее из того, что есть на рынке и пока еще никому не удалось их превзойти! (разумеется, речь идет лишь об автоматизированном восстановлении).

Ничего не записывайте на восстанавливаемый диск и не позволяйте этого делать остальным приложениям! Если вы случайно удалили файл с системного диска, ни в коем случае не выходите из Windows "культурным" способом. Лучше нажмите RESET (при штатом завершении сеанса, система сохраняет на диске текущую конфигурацию, существенно увеличивая риск необратимого затирания удаленного файла).

Не пытайтесь "насиловать" сбойные сектора многократными чтениями – это лишь расширяет дефектную область на соседние сектора и здорово уродует магнитную головку, после чего здоровые сектора не смогут читаться тоже. Лучше выполните длинное (long) чтение с диска с отключенными контролирующими кодами, тогда контроллер возвратит все, что осталось от сектора (зачастую сбой затрагивает только несколько байт).

Если винчестер издает подозрительные звуки типа постукивания или скрежета, немедленно выключите питание компьютера (опять-таки, не позволяя системе ничего писать на диск ), поскольку в любой момент винчестер может доломаться окончательно и тогда ему уже никакой электронщик не поможет.

Восстанавливайте SCSI (и, в особенности, RAID!) диски только на "родном" контроллере (различные контроллеры используют различные схемы трансляции адресов). Если же контроллер сдох, то либо ремонтируйте его, либо ищите точно такой же. С IDE-дисками в этом плане намного проще, – их контроллеры более или менее стандартизованы, однако, с дисками большого объема (свыше 528 Мбайт) уже начинается неразбериха и путаница, ставящая их в зависимость от конкретной BIOS и выбранного режима работы (NORMAL, LBA или LARGE). Если восстанавливаемый диск работает под управлением нестандартных драйверов типа Rocket, OnDisk и т.д., они должны присутствовать и на загрузочной диске (загрузочном CD), с которого производится восстановление.

Наконец, если данные восстановить так и не удалось – не расстраивайтесь. Во всем в жизни надо видеть и хорошие стороны, даже когда ничего хорошего нет.

===== структура диска – базовые концепции =====

Физически жесткий диск представляет собой запечатанную банку с одной или несколькими одно или двухсторонними пластинами, насажанными на шпиндель. Чтение/запись данных осуществляется блоком магнитных головок, каждая их которых обслуживает одну из поверхностей пластины. Информация хранится в форме концентрических колец, называемых //**треками**// (//**track**//) или дорожками. Треки, расположенные на равном расстоянии от центра всех пластин, образуют //**цилиндр**// (//**cylinder**//). Фрагмент трека, образованный радиальным делением, называется //**сектором**// (//**sector**//). В современных винчестерах количество секторов на трек не остается постоянным и дискретно растет по мере удаления от центра пластины, поддерживая более или менее постоянные линейные размеры сектора. Треки и головки нумеруются начиная с нуля, сектора – начиная с единицы. Размер сектора для жестких дисков – 512 байт.

Первой схемой адресации секторов, доставшейся жестким дискам в наследство от дискет, стала так называемая //**CHS**////**-адресация**//, представляющая собой сокращение от Cylinder/Head/Sector (Цилиндр/Головка/Сектор) и возникшая под давлением экономических причин. Когда-то, координаты адресуемого сектора напрямую соответствовали физической действительности, что упрощало (а, значит, и удешевляло!) дисковый контроллер, не требуя от него никакой интеллектуальности. Помимо того, что такая схема адресации чудовищна неудобна для программистов (последовательное чтение диска растягивается на три вложенных цикла!), она еще и до неприличия косна! Количество секторов в треке должно быть постоянным для всего диска, а в новых винчестерах это не так. Поэтому, для сохранения совместимости с существующим программным обеспечением, дисковый контроллер виртуализует геометрию винчестера, что ставит нас в зависимость от выбранной схемы трансляции (а схема трансляции – дело сугубо внутреннее и потому не стандартизированное). Параметры диска, сообщаемые устройством и напечатанные на этикетке, //**всегда**// виртуальные и никакой возможности узнать реальное положение дел у нас нет.

IDE-диски благодаря наличию интегрированного контроллером внутри, в наименьшей степени зависимы от внешнего мира и могут свободно мигрировать от одной машины к другой (при условии корректного поведения BIOS'а, но об этом чуть позже). Некоторые винчестеры поддерживают специальную ATA-команду "Initializedeviceparameters", устанавливающую текущую виртуальную геометрию диска, а точнее выбранное количество головок и число секторов на дорожку. Количество цилиндров вычисляется контроллером самостоятельно, на основании общего объема диска, который кстати говоря, также можно изменять программными средствами (за это отвечает ATA-команда SET MAX ADDRESS). Некоторые драйвера (и BIOS'ы) изменяют геометрию диска, привязывая винчестер к себе прочными брачными узами и в другом окружении такой диск работать уже не будет, ну во всяком случае до установки правильной геометрии.

Со SCSI-устройствами ситуация обстоит гораздо хуже и диск соглашается работать только с тем контроллером, под которым он был отформатирован. Различные контроллеры используют различные схемы трансляции и потому подключение диска к несовместимому контроллеру произвольным образом "перемешивает" сектора. Редактор диска с таким винчестером работать еще будет, а вот штатные средства операционной системы (и большинство "докторов") нет.

Продвинутые контроллеры автоматически замещают плохие сектора, либо сохраняя эту информацию в свой энергонезависимой памяти, либо в записывая ее в инженерные сектора самого диска. Это еще сильнее привязывает накопитель к его контроллеру (правда, некоторые SCSI-диски выполняют переназначение секторов собственными средствами). Таким образом, выход SCSI-контроллера из строя фактически приравнивается к отказу самого диска. Никогда не приобретайте SCSI-контроллеры no-name производителей – в любой момент они могут кануть в лету и тогда поставки новых контроллеров прекратятся. Контроллеры, интегрированные в материнские платы, это вообще песня. Ненадежные, ни с чем не совместимые… а что вы еще хотели за такую цену?

Сложнее всего приходится RAID-массивам, схема трансляции адресов которых полностью определяется контроллером. Массивы уровня 1 (mirroring или зеркала) чаще всего транслируются всквозную и без особых проблем могут быть перенесены на любой другой контроллер или даже подключены в обход него. Массивы остальных уровней (и в особенностей RAID 3/RAID 5) на других типах контроллеров по обыкновению неработоспособны. Программные RAID'ы, монтируемые Windows NT, содержат информацию о своей геометрии в системном реестре и не могут быть непосредственно перенесены на другие системы. Переустановка Windows NT (равно как и крах оной) уничтожает программный RAID. К счастью, эта потеря обратима и в следующих статьях этого цикла мы раскроем секреты техники восстановления.

Несмотря на то, что CHS-трансляция в настоящее время признана устаревшей (устройства, придерживающиеся спецификации ATA/ATAPI-6, принятой в июне 2001 года, уже не обязаны ее поддерживать), она до сих пор встречается во многих служебных структурах операционной системы (в частности в таблице разделов и загрузочном секторе), поэтому имеет смысл остановиться на этом вопросе поподробнее, тем более, что здесь есть о чем поговорить.

На интерфейсном уровне, адрес сектора передается следующим образом (см. листинг 1)

портзначение

0172/01F2кол-во секторов

0173/01F3номер сектора (биты 0-7)

0174/01F4номер цилиндра (биты 0-7)

0175/01F5номер цилиндра (биты 8-15)

0176/01F6номер головки (биты 0-3), привод на шине (бит 4), режим CHS/LBA (бит 6)

Листинг 1 интерфейс с IDE-диском в режиме CHS

Сервисные функции BIOS'а, напротив, адресуют диск слегка по своему:

регистрзначение

ALкол-во секторов для обработки

CHномер цилиндра (биты 0-7)

CLномер цилиндра (биты 6-7), номер сектора (биты 0-5)

DHномер головки

DLпривод на шине | 80h

Листинг 2 интерфейс с прерыванием INT13hBIOS

Таким образом, на адресацию цилиндров BIOS отводит всего 10 бит и потому максимальное количество цилиндров на диске ограничено всего 1024, что при четырех битной адресации головок, дает предельно достижимый объем диска в 512 * 2<sup>10</sup> * 2<sup>6</sup> * 2<sup>4</sup> == 536870912 байт или 512 Мб. Ха! Производители винчестеров перешагнули этот барьер уже много лет назад и с той поры, кстати говоря, очень многое изменилось. MS-DOS ушла небытие, а пришедшая ей на смену Windows работает с диском через собственный драйвер и ограничения BIOS ее никак не касаются. Ну почти не касаются… Ведь первичную загрузку операционной системы осуществляет никто иной как BIOS и если системные компоненты расположены в секторах, находящихся за пределами 1024 сектора, операционная система попросту не будет загружена! Причем, это относиться ко всем операционным системам, а не только к критикуемой Windows!

Для преодоления этого ограничения BIOS вводит дополнительный уровень трансляции (режим LARGE), увеличивая количество головок (благо, BIOS выделяет для их адресации аж 8 бит, против 4 бит, выделяемых контроллером диска). К следствие, предельно допустимый объем диска теперь составляет 512 2<sup>10</sup> 2<sup>6</sup> * 2<sup>8</sup> == 8.589.934.592 байт или 8 Гбайт. Это в теории. На практике же большинство BIOS'ов содержали грубые ошибки и при работе с дисками свыше 2 Гб они либо банально зависали, либо теряли старшие разряды цилиндра, обращаясь к началу диска и необратимо гробя все служебные структуры. До сих пор многие вполне современные BIOS'ы не позволяют адресовать более 64 головок (виртуальных), что ограничивает предельно допустимый объем диска все тем же 2 Гбайтами. Поэтому, при переустановке Windows поверх старой версии на логический диск емкостью свыше 2 Гбайт, она может перестать загружаться. Все очень просто! Когда система ставится на только что отформатированный диск, она располагает все свои файлы в самом начале, но по мере же заполнения диска, область свободного пространства отодвигается все дальше к концу… Кстати говоря, отодвинуть файлы первичной загрузки может и дефрагментатор (или установка пакета обновления). Короче говоря, владельцем больших винчестеров настоятельно рекомендуется разбить свое хозяйство на несколько дисков, установив размер первого (загрузочного) раздела не более, чем в 8 Гбайт, а лучше даже в 2 Гбайта.

SCSI-устройства от рождения поддерживают прозрачный механизм логической адресации, или сокращенно //**LBA**// (//Linear////Block////Address//), последовательно нумерующий все сектора от 0 до последнего сектора диска. В IDE-накопителях LBA-адресация появилась только начиная с ATA-3, но быстро завоевала всеобщее признание. Разрядность адресации определяется устройством. В SCSI она от рождения 32-битная, а IDE-устройства вплоть до принятия спецификации ATA-6 были ограничены 28 битами, которые распределялись следующим образом: 

портзначение

0172/01F2кол-во секторов

0173/01F3номер сектора (биты 0-7)

0174/01F4номер сектора (биты 8-15)

0175/01F5номер сектора (биты 16-24)

0176/01F6номер сектора (биты 24-28), привод на шине (бит 4), режим CHS/LBA (бит 6)

Листинг 3 интерфейс с IDE-диском в режиме LBA

Как можно видеть, 28 битная адресация обеспечивает поддержку дисков с объемом вплоть до 128 Гбайт, однако, включение в BIOS поддержки LBA еще не отменяет 8 Гбайтного ограничения и номер последнего адресуемого цилиндра по прежнему остается равным 1024 со всеми вытекающими отсюда последствиями. SCSI-дискам с их подлинно 32 битной адресацией несколько проще и они поддерживают законные 2 Тбайта, а все потому что управляются своим собственным BIOS'ом, на которых не наложено никаких дурацких пережитков старины.

Утвержденная ATA-6 48 битная адресация расширяет предельно допустимые размеры IDE-дисков до астрономических величин (конкретно – до 131.072 Тбайт), по крайней мере в теории. На практике же, в Windows 2000 с пакетом обновления SP2 или более ранним, отсутствует поддержка 48 разрядной LBA и для работы с большими дисками необходимо обновить драйвер Atapi.sys и добавить к следующему ключу реестра HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\atapi\Parameters параметр EnableBigLba типа DWORD со значением 1. (за подробностями обращайтесь к Microsoft Knowledge Base: 260910).

Один физический диск может быть разбит на несколько //**логических**//, каждый из которых последовательно нумеруется от первого до последнего сектора либо "сквозной" адресацией, либо по CHS-схеме. В одних случаях Windows требует задания абсолютного номера сектора (который на самом деле никакой не абсолютный, а относительный, отсчитывающийся от стартового сектора раздела), в других – ожидает увидеть "святую троицу" (цилиндр, головку, сектор), опять-таки, отсчитывающихся от стартового сектора. Так, если раздел начинается с адреса 123/15/62, то первой его головкой все равно будет головка 0!

На уровне файловой системы операционная система адресует диск //**кластерами**// (//**cluster**//). Каждый кластер образован непрерывной последовательностью секторов, количество которых равно степени двойки (1, 2, 4, 8…). Размер кластера задается на этапе форматирования диска и в дальнейшем уже не меняется. Основное назначение кластеров – уменьшение фрагментации файлов и уменьшение разрядности служебных файловых структур. В частности, FAT16 нумеруют кластеры двойными словами и потому может адресовать не более 10000h*sizeof(cluster) дискового пространства. Легко видеть, что уже на 80 Гбайтовом диске размер кластера составляет 1 Мбайт и десяток файлов по одному байту каждый сожрут 10 Мбайт! Впечатляет, не правда ли? NTFS, оперирующая 64 битными величинами, не страдает подобными ограничениями и типичная величина кластера, выбираемая по умолчанию, составляет всего 4 сектора. В отличии от секторов, кластеры нумеруются начиная с нуля.

===== >>>> врезка первичная диагностика аварии =====

|**симптом**|**диагноз**|**лекарство**|
|жесткий диск не опознается BIOS'ом|отказ электроники жесткого диска|–|
|операционная система не загружается, BIOS выдает надпись "nonsystemdisk", missingoperationsystem или что-то в этом роде|при загрузки с дискеты логические диски не видны (команда C: дает ошибку)|повреждена таблица разделов или сигнатура 55h AAh|восстановите MBR вручную или при помощи GetDataBack|
| ::: |логические разделы видны и исправны (команды C: и dirC: работают)|слетел boot и/или MBR загрузчик|запустите консоль восстановления и дайте команды FIXBMR и FIXBOOT|
| ::: |логические разделы видны, но команда dirC: дает ошибку|поврежден boot-сектор или MTF|восстановите boot-сектор вручную или резервной копии, восстановите MFT из MFTMirr|
|операционная система начинает закружатся, но затем виснет или прерывается с сообщением об ошибке|команда dirC: выполняется нормально, chkdsk не находит ошибок|навернулась сама операционная система|переустановите операционную систему, предварительно скопировав все ценные файлы на другой носитель|
| ::: |команда dir в одном или нескольких подкаталогах выводит мусор или показывает не все файлы|повреждена MTF или одна из ее дочерних структур|запустите Disk Explorer и прочитайте файлы из MFT напрямую в обход индексов|
| ::: |некоторые файлы не читаются, при этом винчестер издает ритмичные скребущие звуи|физические повреждения поверхности диска|запустите утилиту восстановления жесткого диска от его производителя|
| ::: |некоторые файлы содержат в себе фрагменты других файлов|на диске образовались пересекающиеся кластеры|запустите chkdsk|
| ::: |свободное место на диске планомерно уменьшается без видимых причин|некоторые кластеры оказались потерянными|запустите chkdsk|

Таблица 1 симптомы основных заболеваний жестких дисков

===== инструменты =====

Даже если у вас золотые руки и светлая голова, при восстановлении данных ни за что не обойтись без инструментов. В идеале вы должны быть готовыми разработать все необходимое для работы самостоятельно. Восстановление данных – довольно кропотливая и рутинная работа и при реанимации 80 – 120 Гбайтного диска без автоматизации никуда. Недостаток всех известных дисковых докторов – отсутствие встроенного языка или хотя бы развитой системы макрокоманд. Естественно, прежде чем что-то автоматизировать необходимо разобраться в ситуации и выполнить эту работу может только человек. Компьютеру доверять ее ни в коем случае нельзя – для этого он недостаточно интеллектуален. Только человек может надежно отличать где лежат актуальные данные, а где мусор.

Однако, не стоит впадать и в другую крайность, в очередной раз изобретая велосипед. Среди представленных на рынке утилит, есть практически все необходимое. Естественно, большинство распространяются по коммерческой схеме и за них приходится платить. К сожалению, многие из дорогостоящих инструментов не оправдывают своих ожиданий и к выброшенным на ветер деньгам примешивается горечь утраты по безвозвратно потерянным данным. Автор протестировал большое количество разнообразных программных продуктов и ниже описывает наиболее предпочтительные из них, проверенные энтропией и временем.

==== загрузочная дискета ====

Средства восстановления и диагностики, расположенные на основном жестком диске, годятся разве что для обучения, а для реальной работы они бесполезны. Даже если сбой окажется не настольно серьезным, чтобы воспрепятствовать загрузке Windows, попытка "лечения" диска в многозадачной среде носит весьма непредсказуемый характер. Записывая что-либо на диск в обход драйвера файловой системы вы здорово рискуете. Допустим, вы восстанавливаете удаленный файл, обновляя MFT (MasterFileTable – святая святых файловой системы NTFS), а в это время система создает/удаляет другой файл, обращаясь к тому же самому сектору, что и вы. Ну и что произойдет в результате? Правильно – файл, а, возможно, и весь дисковый том, умрет окончательно. К тому же система блокирует активные исполняемые файлы и файлы данных, что делает невозможным их восстановление даже при наличии архивной копии. Про борьбу с вирусами лучше вообще не говорить. Многие вирусы, обосновавшись в системе, блокируют запуск антивирусных программ или умело скрываются от них, не давая себя удалить или обнаружить. Если же в результате сбоя перестала загружаться Windows, вы вообще остаетесь ни с чем…

Главное преимущество FAT16/32 по сравнению с NTFS это, бесспорно, возможность загрузки с системной дискеты. MS-DOS 7.0 поддерживает длинные имена, позволяя скопировать с восстанавливаемого диска все файлы, которые только доступны штатному драйверу операционной системы. Но с NTFS такой номер уже не пройдет! Однако, никто не запрещает нам подключить восстанавливаемый диск "вторым" к системе с работоспособной NT. Для этого даже не обязательно иметь два компьютера. Просто подключите к своему компьютеру еще один винчестер, установите на него NT и наслаждайтесь жизнью. При этом следует учитывать, что информация о программных RAID'ах, созданных Windows NT 4.0 или более ранними версиями, содержится в реестре и потому при переносе диска на другую систему оказывается недоступна. Динамические диски, появившиеся в Windows 2000, хранят свою атрибуты в фиксированных местах диска и потому не привязаны к своей родной системе. С шифрованными файлами дела обстоят не в пример хуже. Ключ шифровки хранится в недрах пользовательского профиля и на другой системе извлечение файлов оказывается невозможным. Причем, создание пользователя с таким же именем/паролем не решает проблемы, т. к. ключ генерируется системой случайным образом и не может быть воспроизведен. Ничего не остается, как действовать тупым перебором.

Некоторые типы разрушений файловой системы способы завешивать оригинальный NTFS-драйвер или выбрасывать синий экран смерти, что создает серьезные проблемы (чтобы восстановить диск, мы должны запустить определенный инструментарий, а чтобы запустить инструментарий, нам надо загрузить Windows, а вот это мы как раз сделать и не можем!). Попробуйте подключить такой диск к системе, не поддерживающий NTFS (например, Windows 98 или MS-DOS), естественно выбранные вами утилиты восстановления должны быть совместимы с ней. Или – как вариант – натравите на такой диск LINUIX. Драйвер LINIX'а игнорирует вспомогательные структуры файловой системы (такие, например, как файл транзакций) и потому успешно монтирует диск даже когда в них содержится сплошной мусор.

Благодаря усилиям Марка Руссиновича, создавшего замечательную утилиту **NTFSDOS Professional**, мы может работать с NTFS-разделами в среде Windows 9x/MS-DOS. Однако, это отнюдь не самостоятельный драйвер, а всего лишь обертка вокруг штатного NTFS.SYS, эмулирующая необходимое окружение и диспетчеризующая файловые запросы. С одной стороны это хорошо тем, что мы имеем полноценную поддержку NTFS, на 100% совместимую с нашей версией операционной системы (NTFS.SYS извлекается как раз оттуда), в то время как драйвера сторонних производителей (и в частности драйвер LINIX'а) реально работают лишь на чтение, да и то кое-как (потоки и прочие "вкусности" NTFS начисто игнорируются). С другой стороны, если порушенный диск завешивает NTFS.SYS, он завесит и Руссиновича! Однако, с такими проблемами приходится сталкиваться не так уж и часто, поэтому полезность этой утилиты воистину неоценима. Демонстрационная копия NTFSDOS Profrssional, доступная для бесплатного скачивания (http://www.sysinternals.com/files/NTFSProR.exe), поддерживает лишь чтение NTFS-дисков, а за возможность записи приходится платить (несите свои денежки на http://www.winternals.com – платный вариант www.sysitnernals.com).. Впрочем, поскольку NTSFDOS Professional всего лишь обертка, после небольшой доработки напильником она с готовностью соглашается и читать, и писать. (Внимание! Никто не говорит о взломе! Мы ничего не ломаем! Напротив, мы создаем, наращивая функциональность программы!). Кратко об установке и сопутствующих проблемах. Для начала вам потребуется создать системную дискету, что легче всего осуществить средствами Windows 98. Русская версия MS-DOS даже в минимальном комплекте поставки (io.sys + command.com) занимает намного больше места, чем рассчитывал Руссинович и NTFSDOS Professional на стандартную 3" дискету уже не вмещается. Поэтому, приходится устанавливать NTFSDOS Professional на чистую диску (точнее говоря, инсталлятор создает таких дисков два – на первый помещает NTFS-драйвер, а на второй – chkdsk.exe). Загрузившись с системной дискеты, выньте ее из дисковода (естественно, command.com должен быть предварительно скопирован на виртуальный диск), вставьте первый диск, сформированный инсталлятором и наберите в командной строке NTFSPRO.EXE.

Как вариант можно воспользоваться загрузочным диском от компании **Active****@****Data****Recovery****Software** (http://download2.lsoft.net/NtfsFloppySetup.exe) или загрузочным CD-ROM диском от нее же (http://download2.lsoft.net/boot-cd-iso.zip). Центральным звеном каждого из них является независимый NTFS-драйвер, работающий из под MS-DOS и монтирующий NTFS тома даже при полном разрушении вспомогательных файловых структур и серьезном повреждении таблицы MFT и полном разрушении корневого каталога. Драйвер самостоятельно сканирует диск в поисках уцелевших записей в MFT, показывая в том числе и удаленные файлы, предлагая их восстановить. Естественно, возможность записи на диск реализована только в коммерческой версии, а демонстрационная позволяет лишь скопировать файлы на внешний носитель (жесткий диск, размеченный под FAT, или дискету). Динамические диски, к сожалению, не поддерживаются. Помимо этого в комплект входит утилита для создания/восстановления образом диска, средство избавления диска от данных (полезно когда вы сдаете диск с конфиденциальными данными назад продавцу), программу для работы с патрициями((  английское partition (раздел) в русской транскрипции, изначально произносилось как "партитио" и "патриция", но затем язык это переварил в более благозвучную и легко выговариваемую "патрицию". )) (восстановление разрушенных таблиц разделов и их заблаговременная архивация), и автономный энурез – утилиту unerase для NTFS.

Если приобретение второго жесткого диска вам не по карману, а возможности MS-DOS загрузчиков вас не устаивают, воспользуйтесь другой утилитой Марка Руссиновичка – **ERD Commander****'ом**, позволяющим запускать усеченную версию Windows с дискет (5 штук) или CD-диска. В настоящее время ERD Commander распространяется только на коммерческом основании, хотя в сети до сих пор можно найти предыдущие, бесплатные версии, хотя их функциональные возможности весьма ограничены. В частности, опробованный мной EDR Commander 2000 вызывал смесь разочарования с удивлением. Во-первых, он забросил на дискету многопроцессорное ядро (а у меня однопроцессорная машина!). Как следствие, при загрузке с дискеты Windows не нашла нужного ядра и умерла еще в зачатье. Пришлось менять ядро вручную. Затем всплыли и другие ошибки инсталлятора и пришлось немало попотеть, прежде чем Windows все-таки загрузилась. Подготовленный инсталлятором образ CD-ROM'а так же был в сильно разобранном стоянии – просто папка с файлами и bootsector.bin, который еще не каждой утилитой прожжешь (я пользовался CDRTOOLS, так же подходит и CDRWIN, а вот популярный Нерон, сжигающий Рим, для этой цели увы, не пригоден). Тем не менее, ERD Commander стоит всех мучений! С его помощью вы можете: менять администраторский пароль в системе, редактировать реестр упавшей системы, управлять сервисами и драйверами, восстанавливать удаленные файлы, копировать и модифицировать любые системные и пользовательские файлы (в том числе и по сети), редактировать таблицу разделов и управлять динамическими дисками, сравнивать файлы упавшей и рабочей системы, производить откат системы в рабочее состояние и многое-многое другое. К сожалению, непосредственными средствами для восстановления разрушенного диска ERD Commander не располагает и в основном он применим для реанимации операционной системы (правда, из под ERD Commander'а вы можете вызвать дискового доктора или любую другую Windows-утилиту, в таком случае никакого смысла в его приобретении нет – второй винчестер будет дешевле).

Начиная с Windows 2000, Microsoft наконец-то включила в операционную систему некоторую пародию на загрузчик, способную стартовать с CD-ROM и поддерживающую NTFS. Называется эта штука //**Консоль Восстановления**// или по-английски //**Recovery**////**Console**//. Это действительно консоль, ничего не знающая о GUI и способная запускать только консольные приложения (типа chkdsk.exe и подобных им). Для ее активации загрузитесь с дистрибутивного CD-ROM и сделайте вид, что хотите переустановить систему, но на определенном этапе установки нажмите <R> для вызова консоли восстановления. Вас запросят пароль администратора (если вы его забыли или системный реестр поврежден войти в консоль не удастся!), при успешной регистрации запуститься командный интерпретатор, позволяющий (теоретически!) скопировать уцелевшие файлы на другой диск. Практически же по умолчанию доступа только папка WINNT, причем копирование на съемные носители запрещено. Хорошенькое начало! Вам нужна WINNT? Личные документы намного нужнее! К счастью, доступ можно разблокировать. Для этого необходимо присвоить системным переменным AllowAllPaths и AllowRemovableMedia значение true ("SET AllowAllPaths = true", "SET AllowRemovableMedia = true"), или локальных параметрах безопасности" (папка Администрирование в Панели Управления) заблаговременно найти пункт "Консоль восстановления: разрешить копирование дискет и доступ ко всем папкам" и перевести рубильник во включенное состояние. Смысл этой защиты не совсем понятен. Простые пользователи до консоли восстановления все равно не дотянуться, а профессионалов подобные манипуляции ужасно раздражают. Находясь в консоли восстановления вы можете: запускать chkdsk((  полезность которого, кстати говоря, весьма сомнительна, т. к. он зачастую лишь усугубляет разрушения )), создавать и удалять разделы на жестком диске, перезаписывать главную запись и boot-record, форматировать логические диски, управлять службами и драйверами, удалять/копировать/переименовывать/изменять атрибуты файлов (включая те, что блокируются при запуске системы), а так же выполнять другие сервисные операции. При желании вы можете запускать и свои собственные консольные приложения, при условии, что они не используют никаких динамических библиотек за исключением NTDLL.DLL, однако, технику их создания мы обсудим как ни будь в другой раз, т. к. это очень обширный вопрос.

В Windows XP идея консоли восстановления получила дальнейшее развитие, в конце концов вылившееся в **Windows PE**. Это – слегка усеченная версия Windows XP, способная грузиться с CD-ROM и запускать GUI-приложения. Фактически она полностью заменят собой "второй" жесткий диск и для восстановления системы теперь не требуется никакого дополнительного оборудования! Несмотря на то, что легальная версия Windows PE в широкую продажу так и не поступала (Microsoft предоставляет ее только разработчикам оборудования, сервисным специалистам и прочим своим корешам), в России копию оригинального диска Windows PE можно найти в каждом ларьке. Пиратство пиратством, но то, что спрос рождает предложение – факт, а загружать Windows с диска требуется многим. Если же вы связаны лицензионными ограничениями, диктуемыми уставом вашей фирмы, воспользуйтесь **Bart's PE Builder'ом**. Эта бесплатно распространяемая утилита (http://www.danilpremgi.com/nu2/pebuilder3032.zip) вытащит с дистрьбютивного диска обыкновенной Windows все необходимые файлы и автоматически сформирует iso-образ загрузочного CD. Прожигаете его на болванку и все! При желании вы можете помещать на CD и свои собственные утилиты, формируя приличную аптечку для восстановления умерших дисков и размещающуюся на 3" CR-R/RW, свободно умещающимся в нагрудном кармане. И не зачем таскать эти жуткие стопки дискет или страшно сказать – отдельный винчестер. К слову сказать, к Bart'sPEBuilder'у выпущено множество плагинов, представляющих собой программы, адоптированные для запуска с CD. Среди них есть и утилиты восстановления данных, и дисковые редакторы, и даже NeroBriningRom. Большую коллекцию плагинов можно найти на домашней страничке Bart'а – http://www.nu2.nu/pebuilder/ здесь же вы найдете и краткое руководство по работе с PEBuilder'ом. Официально PE Builder поддерживает Windows 2000, Windows XP и Windows 2003, однако, при ближайшем рассмотрении выясняется что ему как минимум нужен Windows 2000 с интегрированным SP1, зато создание диска на базе Windows 2003 прошло успешно (использовался CD-ROM с 180-дневной версией Windows 200 Server, бесплатно распространяемый компаний Microsoft).

{{recorever.boot_Image_0.jpg}}

Рисунок 1 логотип диска Bart'sPE

==== выбор носителей для копирования ====

Времена, когда восстанавливаемый винчестер было можно скопировать на пару пачек дискет, давно прошли и теперь процедура спасения данных значительно усложнилась. Пишущие приводы (особенно DVD) – хороший выбор и пара пачек болванок вмещает в себя жесткий диск любой разумной емкости, однако достойных программ прожига под MS-DOS нет и по-видимому уже и не будет. Существующие утилиты (включая их консольные разновидности!) требуют для своего запуска Windows PE/Bart PE, который не в состоянии монтировать разрушенные NTFS-диски (на некоторых из них NTFS-драйвер просто виснет или уходит в голубой экран).

Штатная же консоль восстановления, NTFSDOS Proffessional и Active@ DataRecoveryBootDisk поддерживают только дискеты и IDE-накопители, причем демонстрационные версии двух последних требуют, чтобы диск-приемник был размечены под FAT16/32, а его максимальный объем не превышал 8 Гбайт. Если же вам необходимо восстановить диск большего объема – последовательно копируйте его на несколько жестких дисков. Согласен, это достаточно дорогое удовольствие, но дешевых решений в деле восстановления данных не бывает.

==== редактор диска ====

Настоящие профессионалы восстанавливают разрушенные логические структуры непосредственно в дисковом редакторе, не доверяя никаким автоматизированным утилитам (кроме своих собственных), поскольку никогда не известно наперед, какой подлости от них следует ждать. Так будем поступать и мы, делая основной упор именно на ручном восстановлении. Коль скоро дисковый редактор станет нашим главным инструментом, это должен быть хороший и комфортный редактор, в противном случае, восстановление из увлекательной работы превратится в пытку.

Лучшим, и кстати говоря до сих пор никем не превзойденным, дисковым редактором, когда-либо созданным за всю историю существования IBM PC, был и остается знаменитый **Norton DiskEditor** от компании Symantec. Удобная навигация по диску, просмотр большинства служебных структур в естественном виде, мощный контекстный поиск до предела упростили процедуру восстановления, взяв всю рутинную работу на себя. Старичок и поныне остается в строю. Естественно, под Windows NT он не запускается, однако, работает под MS-DOS и Windows 9x, наследуя все ограничения, накладываемые BIOS'ом на предельно допустимый объем диска в 8 Гбайт (правда, попытка восстановление диска из многозадачной среды, коей и является Winnows 9x, могут носить диаметрально противоположный характер, впрочем, на NTFS-разделы это условие не распространяется. Windows 9x не поддерживает NTFS и ничего не пишет на ее разделы). К сожалению, DiskEdit ничего не знает об NTFS и потому разбирать все структуры приходится вручную. Но еще пол-беды. DiskEdit'or не умеет работать с UNICODE, а это уже хуже. Поэтому, лучше выбрать другой редактор.

{{recorever.boot_Image_1.png}}

Рисунок 2 Disk Editor отображает FAT

{{recorever.boot_Image_2.png}}

Рисунок 3 Disk Editor отображает корневую директорию

**Microsoft****DiskProbe**, входящий в состав бесплатно распространяемого пакета Support Tools, это незатейливый и довольно неудобный в использовании дисковый редактор. Если все, что вам нужно – это подправить пару байт в нужных секторах, Disk Probe вполне подойдет, но для восстановления серьезных разрушений он непригоден. Тем менее, базовые функции редактирования им поддерживаются – чтение (запись) логических/физических секторов и групп, просмотр PartitionTable, FAT16 и NTFSboot-секторов в естественном виде, поддержка UNICODE, глобальный поиск по фиксированному/произвольному смещению строки от начала сектора, запись/восстановление секторов в/из файла и т. д. Основная претензия – отсутствие горячих клавиш и невозможность перехода к следующему сектору по PagePown (для каждого сектора приходится лезть в меню, что ужасно напрягает).

{{recorever.boot_Image_3.png}}

Рисунок 4 DiskProbe за поиском сектора

{{recorever.boot_Image_4.png}}

Рисунок 5 Disk Probe отображает Partition Table

**Acronis DiskEditor** – слегкаулучшенныйклон Disk Probe. Разукрашен интерфейс, существенно упрощена процедура выбора дисков, по PageDown/PageUp переходит к следующему/предыдущему сектору. В поиске появилась поддержка большого количества различных кодировок (DiskProbe понимает только CyrillicWindows-1251), и HEX-поиск. Но есть и упущения. При масштабировании окна меняется и количество байт в строке, что делает навигацию по сектору весьма противоречивой и затруднительной, к тому же текущая позиция курсора отображается только в десятичном виде (у DiskProbe – в шестнадцатеричном), что так же не добавляет восторга.

{{recorever.boot_Image_5.png}}

Рисунок 6 AcronisDiskEditor за поиском строки

{{recorever.boot_Image_6.png}}

Рисунок 7 AcronisDiskEditor отображает NTFSboot-сектор

**DiskExplorer**** от ****Runtime****Software **– великолепный дисковый редактор, самый лучший из всех с которыми мне только доводилось работать. Фактически это клон NortonDiskEditor под Windows NT/9x с полной поддержкой NTFS. Вы можете просматривать все основные NTFS-структуры в естественном виде, монтировать виртуальные диски, работать с образами лазерных и жестких дисков, перемещаться по директориям, восстанавливать удаленные файлы из любой записи MFT, копировать файлы (и даже целые директории!) с предварительным предпросмотром в текстовом или шестнадцатеричном формате и это еще далеко не все! Удобная система forward/backward навигации (приблизительно такая же как в браузере или IDA PRO, даже гиперссылки поддерживаются), изобилие горячих клавиш, история переходов, мощный поиск с поддержкой основных структур (INDEX, MFT, Partition), поиск ссылок на текущий сектор, возможность удаленного восстановления диска с подключением по TCP/IP, локальной сети или прямому кабельному подсоединению. Все числа выводятся в двух системах исчисления – шестнадцатеричной и десятичной.

Короче говоря, это мой основной (и при том горячо любимый!) инструмент для исследования файловой системы и восстановления данных. Первое же знакомство с ним вызывает эйфорию, граничащую со щенячьим восторгом. Наконец-то мы получили то, о чем так долго мечтали. Естественно, за все хорошее надо платить. Disk Explorer это коммерческий продукт, а доступная для скачивания демонстрационная версия лишена возможности записи на диск. Причем, имеются две различные версии редактора: одна поддерживает NTFS (http://www.runtime.org/gdbnt.zip), другая – FAT. Так же доступны плагины под Bart'sPE, которые можно скачать с сайта RuntimeSoftware.

{{recorever.boot_Image_7.png}}

Рисунок 8 DiskExplorer отображает MFT в сокращенном виде

{{recorever.boot_Image_8.png}}

Рисунок 9 DiskExplorer отображает MFT в расширенном виде

**Sector Inspector**, входящий в бесплатно распространяемый фирмой Microsoft пакет "Windows Resource Kits", представляет собой не интерактивный утилиту для чтения/записи отдельных секторов в файл. Поддерживает LBA и CHS адресацию. При запуске без параметров выводит декодированную partitiontable вместе с расширенными разделами и boot-секторами. Редактирование диска осуществляется правкой секторного дампа в любом подходящем HEX-редакторе с последующей записью исправленной версии на диск. Естественно, это непроизводительно и неудобно, однако, SectorInspector единственный известный мне редактор, поддерживающий работу из RecoveryConsole, так что в некоторых случаях он бывает просто незаменим!

{{recorever.boot_Image_9.png}}

Рисунок 10 SectorInspector за работой

==== автоматизированные доктора ====

Более убогой утилиты, чем **ChkDsk** – стандартный дисковый "доктор", входящий в штатный комплект поставки Windows, – по-видимому не придумать даже сценаристам из Голливуда. Система диагностики ошибок упрощена до минимума – доктор лишь информирует о факте их наличия, но отказывается говорить, что именно по его мнению повреждено и что он собирается лечить, поэтому последствия такого "врачевания" могут носить фатальный характер.

Известно много случаев, когда ChkDsk залечивал до смерти полностью исправные разделы. С другой стороны, успешно проведенных операций восстановления на его счету намного больше. Обычно он используется неквалифицированными пользователями (и администраторами) для периодической проверки разделов и исправления мелких искажений файловой системы.

{{recorever.boot_Image_10.png}}

Рисунок 11 ChkDsk за работой

**GetDataBack**от создателя Disk Explorer'а. Полная автоматизация и никакой ручной работы. Сканирует MFT и выводит все файлы, которые только удалось найти (включая удаленные), рассовывая их по директориям (при условии, что соответствующие индексы не повреждены). Если споткнется о BAD-сектор – вылетит не прощаясь. Зато поддерживает удаленное восстановление, создание образов дисков, и мощную систему поиска по файлам (дата/размер), но почему-то нет поиска по содержимому, что не есть хорошо. Допустим, вы хотите восстановить файл со своей диссертацией ключевые слова которой вам известны, а вот в каких секторах они располагаются – не ведомо. Тоже самое относится и к поиску файла записной книжки с телефоном приятеля. Тем не менее, для большинства рядовых задач по восстановлению, возможностей GetDataBack'а хватает с лихвой. Демонстрационную версию программы под NTFS можно раздобыть по адресу (http://www.runtime.org/gdbnt.zip). Она все показывает, но восстанавливать ничего не дает. Однако, позволяет открывать файлы ассоциированным с ними приложениями. Важно отметить, GetDataBack не является доктором, таким как NDD или ChkDsk. Она не лечит разделы, а всего лишь позволяет скопировать из них уцелевшие файлы.

{{recorever.boot_Image_11.png}}

Рисунок 12 внешний вид GetDataBack

**DIY**** ****Recover** от нидерландской фирмы с неоригинальным названием Data Recovery – замечательный полуавтоматический доктор с кучей настроек. Поддерживает динамические диски, позволяет задавать все параметры сканирования вручную. Надежен. Не зависает даже на сильно поврежденных томах. Правда, навигация по восстанавливаемому диску выполнена крайне неудобно (если не сказать – небрежно), что особенно хорошо заметно на больших дисках, содержащих миллионы файлов. Как и его соперник – GetDataBack – он ничего не лечит, а лишь вытягивает уцелевшие данные из небытия. Тем не менее, я отношу DIY Recover к лучшим автоматизированным средствам восстановления из всех имеющихся в моем арсенале (не считая своих собственных утилит, которые пишутся на скорую руку для восстановления конкретного диска, после чего уходят в /dev/null, как и всякий фаст фуд). Демонстрационную копию программы можно найти по следующему адресу http://www.diydatarecovery.nl/~tkuurstra/downloads/Demo/iRecoverSetup.exe.

{{recorever.boot_Image_12.png}}

Рисунок 13 ползущая змейка DIYRecover'a

**Easy Recovery Professional** от OnTrackDataRecovery (www.ontrack.com) – симпатичный, но на проверку довольно бестолковый инструмент, к тому же работающий полностью в автоматическом режиме, интеллектуальность которого находится на зачаточном уровне. Не рекомендуется для использования (ну разве что вы хотите восстановить только что отформатированный том на который еще ничего существенного не писалось). 

{{recorever.boot_Image_13.png}}

Рисунок 14 EasyRecovery и полтораста мегабайт косметики

===== master boot record – базовыеконцепции =====

Первые жесткие диски были небольшого (даже по тем временам) размера и форматировались практически так же, как и дискеты, однако их объемы стремительно росли и MS-DOS уже не могла их целиком адресовать. Для преодоления этого ограничения был введен механизм //**разделов**// (//**partitions**//), разбивающий один физический диск на несколько логических, каждый из который имел свою собственную файловую систему и форматировался независимо от других. За счет чего это достигается?

В первом секторе физического диска (цилиндр 0/головка 0/сектор 1) хранится специальная структура данных – maserbootrecord (главная загрузочная запись) или сокращенно MBR. Она состоит из двух основных частей – первичного загрузчика (master boot code) и таблицы разделов (partitiontable), описывающей схему разбиения и геометрию каждого из логических дисков. В конце сектора по смещению 1FE находится сигнатура 55h AAh, по которой BIOS определяет признак "загрузочности" сектора. Даже если вы не хотите дробить свой винчестер на части и форматируете его как один диск, присутствие maserbootrecord обязательно.

{{recorever.boot_Image_14.png}}

Рисунок 15 схематичное представление разбитого диска

При старте компьютера, BIOS выбирает загрузочный винчестер (обычно PrimaryMaster, но порядок загрузки в большинстве BIOS'ов можно изменять, а самые продвинутые из них при удержании ESC по время прохождения post'а (процесса начального тестирования оборудования) даже выводят интерактивное меню), считывает первый сектор (цилиндр 0/головка 0/сектор 1) в память по адресу 0000h:7C00h, проверяет наличие сигнатуры 55h AAh в его конце и если такая сигнатура действительно обнаруживается передает управление на 0000h:7C000h. В противном случае анализируется следующее загрузочное устройство, а если таковое отсутствует – выдается ругательное сообщение.

Первичный загрузчик, получив управление, сканирует partitiontable (которая уже загружена в память!), находит активный раздел (Boot Indicator === 80h), извлекает номер стартового сектора раздела, так же называемого boot-сектором, загружает его в память по адресу 0000h:7C00h (предварительно переместив свое тело в другое место, чтобы избежать затирания), убеждается в наличие сигнатуры 55h AAh, передавая управление по 0000h:7C00h, в противном случае выдается ругательное сообщение и после нажатия на клавишу компьютер перезагружается. Некоторые загрузчики поддерживают несколько активных разделов, последовательно перебирая их один за другим, но это уже отсебятина разработчиков, выходящих за стандартные спецификации Microsoft, что, впрочем, никого не смущает.

Если первичный загрузчик поврежден, то BIOS не сможет запустить операционную систему с такого диска, однако, при подключении его "вторым" (или загрузке с дискеты) все логические диски будут доступны. Как минимум они должны быть "видны", т. е. команды C:, D:, . E: выполняются нормально, правда работоспособность команды dir уже не гарантируется. Во-первых, для этого файловая система соответствующего раздела должна быть известна загруженной операционной системе и не повреждена, а, во-вторых, должен быть цел boot-сектор (но об этом позже). 

PartitionTable, которую анализирует masterbootcode, а чуть позже – драйвер логических дисков операционной системы, состоит из четырех 10h записей, расположенных по смещению 1BEh, 1CEh, 1DEh, 1EEh байт от начала диска соответственно. Каждая из них описывает свой логический раздел, задавая его стартовый и конечный сектора, записанные в CHS-формате (да! даже если диск работает в LBA-режиме, патриции все равно адресуются через CHS!). Поле относительное смещение раздела, отсчитываемое от начала таблицы разделов, является вспомогательным и его избыточность очевидна. Тоже самое относится и полю с общим количеством секторов на диске – как будто это нельзя вычислить на основе стартового и конечного секторов! Одни операционные системы и загрузчики игнорируют вспомогательные поля, другие же их активно используют, поэтому они должны соответствовать действительности.

Поле идентификатора диска содержит уникальную 32-разрядную последовательность, помогающую операционной системе отличить один смонтированный диск от другого и автоматически копирующую в следующий ключ реестра: HKLM\SYSTEM\MountedDevices. На самом деле, Windows свободно обходится и без него, поэтому содержимого этого поля некритично.

Поле Boot ID содержит идентификатор файловой системы, установленной на разделе, который в случае NTFS равен 07h. За динамическими дисками, согласно фирменной спецификации, закреплен идентификатор 42h. На самом деле, это справедливо лишь для тех из них, что получены путем обновления (update) обычного раздела до динамического. Сведения об остальных динамических дисках в таблице разделов не хранятся, а содержатся в последнем мегабайте физического диска в LDM-базе, и для стандартных дисковых менеджеров они не видны. При установке операционной системы семейства Windows 9х или UNIX на винчестер, содержащий динамические диски, они могут быть необратимо утеряны, поскольку согласно таблице разделов занятое ими пространство отмечено как свободное. Тем не менее, загрузочный логический диск (независимо от того динамический он или нет) в обязательном порядке должен присутствовать в partitiontable, иначе BIOS не сможет его загрузить.

Четырех записей partitiontable, обеспечивающих всего четыре логических диска, явно не хватало, но расширять таблицу разделов было уже некуда – последняя запись упиралась в конец сектора, а использовать следующий сектор разработчиком не хотелось, поскольку его активно использовали многие вирусы и нестандартные драйвера, к тому же это все равно не решало проблемы, а лишь оттягивало конец. Тогда инженеры нашли другое решение, предложив концепцию расширенных разделов (Extendedpartition). Если boot ID некоторого раздела равен 05h или 0Fh, он трактуется как "виртуальный физический диск"((  термин мой – примечание автора )), со своей собственной partitiontable, расположенной в его начале, на которую и указывает стартовый сектор расширенного раздела. Короче говоря, таблица разделов получается вложенной и уровень вложения ограничен разве что свободным местом жесткого диска и количеством стековой памяти загрузчика (при условии, что он использует рекурсивный алгоритм сканирования). Таблица разделов как бы размазывается вдоль винчестера. Большинство утилит резервирования сохраняют лишь первый сектор, чего явно недостаточно (впрочем, первый сектор гибнет намного чаще других, так что даже плохая политика резервирования лучше, чем совсем ничего).

{{recorever.boot_Image_15.png}}

Рисунок 16 расширенная таблица разделов

Штатные утилиты разбивки (FDISK.EXE, DiskManager) в каждой таблице разделов создает один основной и один расширенный раздел. Т. е. если при разбиении винчестера на четыре логических диска, на нем образуется четыре partitiontable (см. листинг 4), хотя в данном случае можно было бы обойтись и одной. Штатный загрузчик FDISK'а требует, чтобы активный раздел находится в первом секторе partitiontable, "благодаря" чем операционная система может грузиться только с диска C:. Нестандартные менеджеры, анализирующие всю цепочку разделов, позволяют загружаться с любого из разделов. Самые честные из них создают в первой partitiontable еще один раздел (благо если диск был разбит FDISK'ом свободное место там всегда есть), назначают его активным и помещают в него свое тело. Другие же внедряются непосредственно в MBR, замещая первичный загрузчик, что создает очевидные проблемы совместимости.

Если таблица разделов повреждена, логические диски скорее всего будут полностью недоступны – они отсутствуют в "Моем Компьютере", не появился в панели "Driver" файлового менеджера FAR'а, а команда C: вызывает ошибку. Искажение таблицы разделов не приводит к немедленному изменению объема уже отформатированных томов (т. к. он храниться в boot-секторе и картах свободного пространства), но при последующим переформатировании произойдет затирание данных из соседнего раздела, или же текущий раздел окажется усечен. Кстати говоря, если расширенный раздел указывает сам на себя или на один из предшествующих разделов в цепочке, все известные мне операционные системы наглухо зависнут еще на этапе загрузки, даже если диск подключен "вторым". Чтобы исправить ситуацию, необходимо запустить редактор диска или другую утилиту, а для этого необходимо загрузить операционную систему! Существует несколько путей выхода из этой, казалось бы неразрешимой проблемы. Самое простое – горячее подключение диска на ходу с последующей работой с ним через BIOS или порты ввода/вывода. Если ни диск, ни материнская плата не умет (а для IDE-устройств подключение "на лету" представляется довольно жестким испытанием!), вы сможете запустить доктора и работать с диском на физическом уровне. Другой, чисто хакерский, путь – пропатчить MS-DOS, изменив сигнатуру 55h AAh на что-нибудь еще, тогда она не сможет распознать таблицу разделом и стало быть, не станет ее анализировать. Как вариант можно записать в boot-сектор дискеты специально подготовленную программу, которая обнуляет MBR или искажает сигнатуру, расположенную в его конце. Просто загрузитесь с нее и все!

|**смещение**|**размер**|**назначение**|
|0x000|перемен.|код загрузчика|
|1x1BB|4h|идентификатор диска|
|0x1BE|10h|Partition 1 |
|0x1CE|10h|Partition 2|
|0x1DE|10h|Partition 3|
|0x1EE|10h|Partition 4|
|0x1FE|0x2|признак таблицы разделов  сигнатура 55hAah|

Таблица 2 формат MBR

|**смещение**|**разм.**|**назначение**|
|000|1BE|1CE|1DE| 1EE|byte|флаг активного загрузочного раздела. (Boot Indicator)\\ 80h – загрузочный раздел, 00h – не загрузочный|
|001|1BF|1CF|1DF|1EF| |стартовая головка раздела|
|002|1C0|1D0|1E0|1F0|byte|стартовый сектор раздела (биты 0 – 5)\\ старшие биты стартового цилиндра (биты 6-7)|
|003|1C1|1D1|1E1|1F1|byte|младшие биты стартового цилиндра (биты 0-7)|
|004|1C2|1D2|1E2|1F2|byte| идентификатор системы (BootID), см. таблицу.4|
|005|1C3|1D3|1E3|1F3|byte|конечная головка раздела|
|006|1C4|1D4|1E4|1F4|byte|конечный сектор раздела (биты 0 – 5)\\ старшие биты конечного цилиндра (биты 6-7)|
|007|1C5|1D5|1E5|1F5| |младшие биты конечного цилиндра (биты 0-7)|
|008|1C6|1D6|1E6|1F6|dword|смещение раздела относительно начала таблицы разделов в секторах|
|00С|1CA|1DA|1EA|1FA|dword|кол-во секторов раздела|

Таблица 3 формат partition

| BootID|тип раздела|
|00h|раздел свободен|
|0x01|FAT12 (менее чем 32.680 секторов в томе или 16 Мбайт)|
|0x04|FAT16 (32,680-65,535 секторов или 16-33 Мбайт)|
|0x05|расширенныйраздел (extended partition)|
|0x06|BIGDOS FAT16 раздел (33 Мбайт – 4 Гбайт)|
|0x07|NTFS-раздел|
|0x0B|FAT32 раздел|
|0x0C|FAT32 раздел с поддержкой расширенной BIOSINT 13h|
|0x0E|BIGDOSFAT16 раздел с поддержкой расширенной BIOSINT 13h|
|0x0F|расширенный раздел с поддержкой расширенной BIOSint 13h|
|0x12|EISA раздел|
|0x42|динамический диск|
|0x86|legacy FT FAT16 раздел|
|0x87|legacy FT NTFS раздел|
|0x8B|Legacy FT volume formatted with FAT32 *|
| 0x8C|Legacy FT volume using BIOS INT 13h extensions formatted with FAT32|

Таблица 4 возможные значения Boot ID

Sector Inspector  Copyright Microsoft Corporation 2003

===========================================================================

Target - \\.\PHYSICALDRIVE0  

 1867  Cylinders

 255  Heads  

 63  Sectors Per Track 

 512  BytesPerSector  

 12  MediaType  

LBN 0  [C 0, H 0, S 1]

===========================================================================

 Master Boot Record

===========================================================================

| B | FS TYPE |  START  |  END  |  |  |

| F |  (hex)  |  C  H  S|  C  H  S|  RELATIVE  |  TOTAL  |

===========================================================================

| * |  07  |  0  1  1| 764  254  63|  63|  12289662|

|  |  0f  | 765  0  1|1023  254  63|  12289725|  17687565|

|  |  00  |  0  0  0|  0  0  0|  0|  0|

|  |  00  |  0  0  0|  0  0  0|  0|  0|

===========================================================================

LBN 12289725  [C 765, H 0, S 1]

===========================================================================

 Extended Boot Record

===========================================================================

| B | FS TYPE |  START  |  END  |  |  |

| F |  (hex)  |  C  H  S|  C  H  S|  RELATIVE  |  TOTAL  |

===========================================================================

|  |  07  | 765  1  1|1023  254  63|  63|  8193087|

|  |  05  |1023  0  1|1023  254  63|  8193150|  4096575|

|  |  00  |  0  0  0|  0  0  0|  0|  0|

|  |  00  |  0  0  0|  0  0  0|  0|  0|

===========================================================================

LBN 20482875  [C 1275, H 0, S 1]

===========================================================================

 Extended Boot Record

===========================================================================

| B | FS TYPE |  START  |  END  |  |  |

| F |  (hex)  |  C  H  S|  C  H  S|  RELATIVE  |  TOTAL  |

===========================================================================

|  |  07  |1023  1  1|1023  254  63|  63|  4096512|

|  |  05  |1023  0  1|1023  254  63|  12289725|  5397840|

|  |  00  |  0  0  0|  0  0  0|  0|  0|

|  |  00  |  0  0  0|  0  0  0|  0|  0|

===========================================================================

LBN 24579450  [C 1530, H 0, S 1]

===========================================================================

 Extended Boot Record

===========================================================================

| B | FS TYPE |  START  |  END  |  |  |

| F |  (hex)  |  C  H  S|  C  H  S|  RELATIVE  |  TOTAL  |

===========================================================================

|  |  07  |1023  1  1|1023  254  63|  63|  5397777|

|  |  00  |  0  0  0|  0  0  0|  0|  0|

|  |  00  |  0  0  0|  0  0  0|  0|  0|

|  |  00  |  0  0  0|  0  0  0|  0|  0|

===========================================================================

Листинг 4 пример таблицы разделов, сформированный программой FDISK

===== masterbootrecord – техника восстановления =====

Существуют множество утилит для автоматического восстановления masterbootcode и partitiontable (Get Data Back, Easy Recovery, ActiveDataRecoverySoftware и т. д.). До некоторого времени они вполне успешно справлялись со своей задачей, восстанавливая даже полностью уничтоженные таблицы разделов, однако с появлением емких винтов, преодолевших барьер в 2 Гбайт с помощью всевозможных расширений, они стали часто путаться и потому доверять им нельзя. Если не хотите потерять свои данные – восстанавливайте MBR самостоятельно (тем более, что это достаточно простая операция, не требующая особой квалификации). Восстановление значительно упрощается, если в вашем распоряжении имеется копия таблицы разделов, снятая Sector Inspector'ом или подобными ей утилитами. Однако, чаще всего ее все-таки нет…

Если операционная система отказывается загружаться, а на экране появляется ругательство от BIOS типа "Disk Boot failure, Non-System disk or disk error... PressEntertorestart", это указывает на разрушение сигнатуры 55h AAh, обычно сопровождаемое смертью первичного загрузчика. Внимание! Очень важно отличать сообщение BIOS от сообщений первичного загрузчика и boot-сектора. Зайдите в BIOS Setup и отключите все загрузочные устройства, оставив активным только диск A: с вытащенной дискетой. А теперь перезагрузитесь и запомните какое сообщение появится на экране. Это и будет ругательством BIOS'а.

Восстановить сигнатуру 55h AAh можно в любом дисковом редакторе. Когда будете это делать, убедитесь, что в начале диска присутствуют осмысленный masterbootcode (если вы испытываете затруднение с дизассемблированием в уме, воспользуйтесь IDA PRO или HIEW'ом). Вы не умеете дизассемблировать? Тогда попробуйте оценить степень "нормальности" первичного загрузчика визуально (однако, для этого опять-таки требуется опыт работы с кодом). В начале более или менее стандартного загрузчика расположено приблизительно 100h байт машинного кода, в котором обнаруживаются последовательности: 00 7С, 1B 7C, BE 07, CD 13, CD 18, CD 10, 55 AA, а затем идут характерные текстовые сообщения: Invalidpartitiontable, Errorloadingoperatingsystem, Missingoperatingsystem..... ну или подобные им. Если загрузчик поврежден, но сигнатура 55 AA цела, то попытка загрузки с такого диска оберется неизменным зависанием.

Восстановить "слетевший" или искореженный первичный загрузчик можно с помощью утилиты FDISK.EXE, запущенной с ключом /MBR, записывающий в главную загрузочную запись первого диска стандартный masterboorcode, или командой FIXMBR консоли аварийного восстановления в Windows 2000 (недокументированный ключ /CMBR, появившийся в MS-DOS 7.0, позволяет выбирать любой из подключенный дисков). Внимание! Если вы использовали нестандартный загрузчик (такой, например, как LILO), то после перезаписи MBR сможете загружаться только с основного раздела, а для запуска операционных систем из других разделов, вам придется переустановить свой мультизагрузочный менеджер (вообще-то, такой менеджер можно написать и самостоятельно, при наличии HIEW'а, а если лучше транслятора ассемблера – работа не займет и получаса).

Как уже говорилось, некоторые загрузчики изменяют схему трансляции адресов жесткого диска и со штатным загрузчиком такой диск будет полностью не работоспособен. Попробуйте переустановить загрузчик с дистрибьютивных дисков – быть может, это поможет. В противном случае, ничего не остается как писать свой собственный загрузчик, определять текущую геометрию диска и соответствующим образом транслировать секторные адреса. Это довольно сложная задача, требующая серьезной подготовки и здесь ее лучше не обсуждать.

Если загрузчик говорит "Invalidpartitiontable", это еще не обозначает, что таблица разделов повреждена, просто ни один из основных разделов не назначен активным. Такое случается при использовании нестандартных загрузчиков, загружающих операционную систему из расширенного раздела. После выполнения команды FDISK /MBR или установке операционной системы, автоматически заменяющий первичный загрузчик своим собственным, он, не обнаружит в пределах досягаемости ни одного активного раздела, и естественно разразится многоэтажным ругательством. Такое поведение в частности характерно для Windows 98. Для решения проблемы либо восстановите прежний загрузчик, либо установите операционную систему на первичный раздел и, запустив FDISK, сделайте его активным.

Загрузитесь с системной дискеты (другого винчестера, CD-диска) и посмотрите – видны ли ваши логические диски или нет. Если да, то смело переходите к следующему пункту, в противном случае соберитесь с духом и приготовьтесь немного поработать руками и головой.

Восстановление основного раздела, созданного FDISK'ом или DiskManager'ом в большинстве случаев осуществляется элементарно, а остальные, как правило, восстанавливать и не требуется, поскольку именно MBR гибнет чаще всего, а расширенные патриции, рассредоточенные по диску дохнут разве что при явном удалении разделов средствами FDISK/Disk Manager.

Адрес стартового сектора первого логического диска всегда равен 0/1/1 (Cylinder/Head/Sector), относительный (Relative) сектор – количеству головок жестка диска уменьшенных на единицу (сведения о геометрии диска можно почерпнуть из любого дискового редактора, в том числе и Sector Inspector'a). Конечный сектор определить несколько сложнее. Если загрузочный сектор цел (см. "загрузочный сектор – техника восстановления"), то узнать количество секторов в разделе патриции (totalsectors) можно и из поля BootRecord.NumberSectors, увеличив его значение на единицу. Тогда конечный цилиндр будет равен LastCyl := TotalSectors/(Heads*SecPerTrack), где Heads – кол-во головок на физическом диске, а SecPerTrack – кол-во секторов на трек. Конечная головка равна LastHead := (Total Sector – (LastCyl*Heads SecPerTrack))/SecPerTrack, а конечный сектор равен LastSec :== (Total Sector – (LastCyl*Heads SecPerTrack)) % SecPerTrack. Пропишите полученные значения в MBR и посмотрите – не находится ли за вычисленным концом раздела следующий раздел? Это должна быть либо расширенная таблица разделов, либо boot-сектор. Если это так, создайте еще одну запись в partitiontable, заполнив его соответствующим образом.

А если boot-сектор отсутствует и не может быть восстановлен – реально ли восстановить таблицу разделов или нет? Да, можно. Необходимо лишь найти boot или partition следующих разделов, в чем вам поможет контекстный поиск. Ищите сектора, содержащие сигнатуру 55h AAh в конце. Отличить boot от partition очень просто (в boot секторе по смещению два байта от его начала расположен идентификатор производителя (NTFS, MSWIN4.1 и т.д.). Логично, что размер текущего раздела на один сектор меньше, а зная размер и геометрию диска можно рассчитать и конечный цилиндр/головку/сектор.

Только учтите, что Windows хранит копию boot сектора, которая в зависимости от версии может быть расположена либо в середине раздела, либо в его конце. Другие копии могут находится в архивных файлах и файле подкачке. Кстати говоря, посмотрите – не содержится ли среди них ничего удобоваримого –  Как отличить копию сектора от оригинала? Элементарно, Ватсон! Если это подлинник вслед за ним пойдут служебные структуры файловой системы (в частности, для NTFS таблица MFT, каждая запись которой начинается с легко узнаваемой строки FILE*). Собственно говоря, поскольку служебные структуры файловой системы обычно располагаются на более или менее предсказуемом смещении относительно начала раздела, то отталкиваясь от их "географического" расположения, мы может установить размеры каждого из логических дисков, даже если все-все-все boot/partition уничтожены.

Что произойдет, если границы разделов окажутся определенными неверно? Если мы переборщим, увеличив размер раздела сверх необходимо, все будет нормально работать, поскольку карта свободного пространства хранится в специальной структуре (у NTFS это файл $bitmap, а у FAT13/32 – непосредственно сама FAT-таблица) и "запредельные" сектора будут добавлены только после переформатирования раздела. Если все что нам нужно – это скопировать данные с восстанавливаемого диска на другой носитель, но возиться с подгонкой параметров partitiontable не нужно! Распахните ее на весь физический диск и дело с концом!

Естественно, такой способ восстановления подходит только для первого раздела диска, а для всех последующих нам потребуется определить стартовый сектор. Это определение должно быть очень точным, поскольку все структуры файловой системы адресуются от начала логического диска и ошибка в один-единственный сектор сделает весь этот тонкий механизм полностью неработоспособным. К счастью, некоторые из структур ссылаются сами на себя, давая нам ключ к разгадке. В частности, файлы $mft/$mftmiff содержат номер своего первого кластера. Стоит нам найти первую запись FILE*, как мы узнаем на каком именно секторе мы сейчас находится (конечно, при условии, что сумеем определить количество секторов на кластер, но это уже другая тема – см. загрузочный сектор – базовые концепции).

==== >>>> врезка проблема нулевой дорожки ====

Главная загрузочная запись жестко держит за собой первый сектор и если он вдруг окажется разрушенным, работа с таким диском станет невозможной. До недавнего времени проблема решалась посекторным копированием винчестера с переносом данных на здоровый жесткий диск с идентичной геометрией с последующий восстановлением MBR.

Сейчас ситуация изменилась. Современные винчестеры поддерживают возможность принудительного замещения плохих секторов из резервного фонда (а некоторые делают это автоматически), поэтому проблема нулевой дорожки, преследующая нас еще со времен гибких дисков и 8-разрядных машин, наконец перестала существовать.

Механизм замещение секторов все еще не стандартизирован и осуществляются утилитами, предоставляемые производителем конкретной модели винчестера. Чаще всего они распространяются бесплатно и могут быть свободно найдены в сети.

0x0000  eb 2e 49 50 41 52 54 20-63 6f 64 65 20 30 30 39  ы.IPART code 009

0x0010  20 2d 20 49 6f 6d 65 67-61 20 43 6f 72 70 6f 72  - Iomega Corpor

0x0020  61 74 69 6f 6e 20 2d 20-31 31 2f 32 33 2f 39 30  ation - 11/23/90

0x0030  fa fc 8c c8 8e d0 bc 00-7c 8e d8 8e c0 b9 00 02  ·№М╚О╨╝.|О╪О└╣..

0x0040  bf 00 7e be 00 7c f3 a4-e9 00 02 fb bd 00 7e 8b  ┐.~╛.|єдщ..√╜.~Л

0x0050  fd be be 01 b9 04 00 80-3a 80 74 0b 83 c6 10 e2  ¤╛╛.╣..А:Аt.Г╞►т

0x0060  f6 8b b5 b2 01 eb 51 56-83 c6 10 49 e3 0b 80 3a  ЎЛ╡▓.ыQVГ╞►Iу.А:

0x0070  80 75 f5 8b b5 b0 01 eb-3f 5e 56 8a 12 8a 72 01  АuїЛ╡░.ы?^VК↕Кr.

0x0080  8a 4a 02 8a 6a 03 bb 00-7c be 05 00 56 b8 01 02  КJ.Кj.╗.|╛..V╕..

0x0090  cd 13 73 0e 33 c0 cd 13-5e 4e 75 f0 8b b5 b4 01  ═‼s.3└═‼^NuЁЛ╡┤.

0x00a0  eb 16 5e be fe 7d 81 3c-55 aa 74 06 8b b5 b6 01  ы▬^╛■}Б<Uкt.Л╡╢.

0x00b0  eb 06 5e 03 f5 e9 48 fd-e8 1b 00 8b b5 b8 01 e8  ы.^.їщH¤ш←.Л╡╕.ш

0x00c0  14 00 b4 00 cd 16 33 c0-8e c0 26 c7 06 72 04 34  ¶.┤.═▬3└О└&╟.r.4

0x00d0  12 ea f0 ff 00 f0 03 f5-ac 3c 00 74 0b 56 b4 0e  ↕ъЁ .Ё.їм<.t.V┤.

0x00e0  bb 07 00 cd 10 5e eb f0-c3 49 6e 76 61 6c 69 64  ╗..═►^ыЁ├Invalid

0x00f0  20 70 61 72 74 69 74 69-6f 6e 20 74 61 62 6c 65  partition table

0x0100  00 44 69 73 6b 20 69 73-20 6e 6f 74 20 62 6f 6f  .Disk is not boo

0x0110  74 61 62 6c 65 00 45 72-72 6f 72 20 6c 6f 61 64  table.Error load

0x0120  69 6e 67 20 6f 70 65 72-61 74 69 6e 67 20 73 79  ing operating sy

0x0130  73 74 65 6d 00 4d 69 73-73 69 6e 67 20 6f 70 65  stem.Missing ope

0x0140  72 61 74 69 6e 67 20 73-79 73 74 65 6d 00 0d 0a  rating system...

0x0150  52 65 70 6c 61 63 65 20-61 6e 64 20 73 74 72 69  Replace and stri

0x0160  6b 65 20 61 6e 79 20 6b-65 79 20 77 68 65 6e 20  ke any key when

0x0170  72 65 61 64 79 0d 0a 00-00 00 00 00 00 00 00 00  ready...........

0x0180  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................

0x0190  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................

0x01a0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 45 06  ..............E.

0x01b0  e9 00 01 01 16 01 35 01-4e 01 6a 72 a5 d5 00 00  щ...▬.5.N.jrе╒..

0x01c0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................

0x01d0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................

0x01e0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 80 01  ..............А.

0x01f0  01 00 06 3f 20 5f 20 00-00 00 e0 ff 02 00 55 aa  ...? _ ...р ..Uк

Листинг 5 внешний вид типичного MBR-сектора

===== динамические диски =====

Динамические диски, впервые появившиеся в Windows 2000 – это все тот же программный RAID, призванный преодолеть ограничения стандартных механизмов разбиения с учетом ошибок своего прямого предшественника программного RAID'а Windows NT, хранящего конфигурационную информацию в системном реестре, что во-первых, препятствовало его перемещению с машины на машину, а во-вторых делало очень уязвимым к порче реестра.

==== >>>> врезка типы динамических дисков, поддерживаемые Windows 2000 ====

**простые (simple)**практически ничем не отличаются от обычных разделов, за исключением того, при переразбиении диска отпадает необходимость в перезагрузке. Базовый тип для всех остальных динамических дисков.

**избыточность**:нет

**эффективность**:низкая

с**оставные (spanned)**состоят из одного или нескольких simple-дисков, находящихся в различных разделах или даже устройствах, представленный как один логический диск. Данные на simple-диски пишутся последовательно (классический линейный RAID).

**избыточность**:нет

**эффективность**:низкая

**чередующиеся (stripped) **тоже самое, что и spanned, но данные записываются параллельно на все simple-диски. при условии, что они расположены на различных каналах IDE-контроллера это значительно увеличивает скорость обмена данными. короче говоря, классический RAID уровня 0.

**избыточность**:нет

**эффективность**:средняя

**зеркальные (mirrored)**два simple-диска, расположенные на разных устройствах. данные дублируются на оба носителя (RAID уровня 1).

**избыточность**:средняя

**эффективность**:средняя

**чередующиеся с контролем четности (stripped ****with****party****): **соответствует массиву RAID уровня 5. Состоит из трёх, или более дисков. Представляет из себя stripped volume с контролём ошибок. Данные пишутся на два диска, в два блока, а на третий диск, и в третий блок записывается ECC, код коррекции ошибок, с помощью которого, по информации любого из блоков можно востановить содержимое второго блока.

**избыточность**:высокая

**эффективность**:высокая

**зеркальный с чередованием (****mirrored****striped****)** соответствует массиву RAID 1+0.

**избыточность**:средняя

**эффективность**:высокая

==== <<<< ====

По умолчанию Windows создает базовые диски (см. расшифровку терминов в таблице 5), но всякий базовый диск в любой момент времени может быть обновлен до динамического (это даже не потребует перезагрузки). Динамические диски не пользуются таблицей разделов, а потому и не имеют проблем, связанных с ограничением CHS-разрядности и позволяют создавать тома практически неограниченного размера. Однако, динамические диски, созданные путем обновления основных разделов, все-таки остаются в partitiontable, при этом их BootID меняется на 42h. Если эта информация окажется удалена, система откажется подключать такой динамический диск. Кстати говоря, Windows может быть установлена только на обновленный динамический диск, поскольку BIOS может загружать систему лишь с тех разделов которые перечислены в partitiontable, а динамические диски, созданные "на лету" в нее как раз и не попадают.

Схема разбиения динамических дисков содержаться в Базе Менеджера Логических Дисков – LogicalDiskManagerDatabase или сокращенно LDM. Это протоколируемая (journalled) база данных, поддерживающая транзакции и устойчивая к сбоям. Если в процессе манипуляции с томами неожиданно исчезнет питание, при последующем включении компьютера будет выполнен откат в предыдущее состояние. При переносе винчестера, содержащего один или несколько динамических дисков, на другую систему, они автоматически распознаются и монтируются, как обыкновенные диски.

LMD-база хранится в последнем мегабайте жесткого диска, а для дисков, полученных путем обновления базового раздела до динамического – в последнем мегабайте этого самого раздела, а идентификатор системы BootID соответствующей записи в PartitionTable принимает значение 42h. Так происходит потому, что при стандартном разбиении винчестера в его конце просто не остается свободно места и операционной системе приходится сохранять эту информацию непосредственно в самом обновляемом диске (естественно, для этого в нем должен быть свободен по меньшей мере 1 Мбайт).

Сразу же за таблицей разделов по адресу 0/0/2 расположен приватный заголовок PRIVHEAD, содержащий в себе ссылки на основные структуры LDM (см. рис. 17). Если PRIVHEAD погибнет, Windows не сможет обнаружить и смонтировать динамические диски. А гибнет он удручающее часто. Подавляющее большинство загрузочных вирусов и дисковых менеджеров считают сектор 0/0/2 свободным и используют его для хранения своего тела, необратимо затирая прежнее содержимое. Осознавая значимость PRIVHEAD'а, парни из Microsoft (разработчики) сохранили его аж в двух копиях – одна из которых хранится в хвосте LDM, а другая – в последнем секторе физического диска. Благодаря такой избыточности, PRIVHEAD практически никогда не приходится восстанавливать вручную, но это все-таки потребуется сделать, обратитесь к проекту LINUX-NTFS за подобным описанием его структуры (http://linux-ntfs.sourceforge.net), здесь же оно по соображениям экономии места, не приводится.

{{recorever.boot_Image_16.png}}

Рисунок 17 LMD-база и ее дислокация

Внутреннее устройство LDM-база недокументированно и буквально пышет мощью и сложностью. Наверху иерархии расположено оглавление базы – структура TOCBLOCK (TableOfContentBlock), состоящая из двух секций config и log (вероятно, в будущем их список будет расширен). Секция config содержит информацию о текущем разбиении динамических дисках и сведения о томах, а log хранит журнал изменений схемы разбивки. Это очень мощное средство в борьбе с энтропией! Если удалить один или несколько динамических разделов, информация о старом разбиении сохранится в журнале и утерянные тома могут быть с легкостью восстановлены! Будучи очень важной структурой, оглавление диска защищено от случайного разрушения тремя копиями, одна из которых вплотную примыкает к настоящему TOCBLOCK'у, расположенному в начале LDM-базы, а две других находится в конце диска, между копиями PRIVHEAD.

Внутренне секция config состоит из заголовка (VMDB) и одного или нескольких VBLKs – специальных 128-байтовых структур данных, каждая из которых описывает соответствующий ей том, контейнер, раздел, диск или группу дисков. VMDB-заголовок не имеет копии и нигде не дублируется, однако все его изменения протоколируется в журнале (KLOG) и потому могут быть восстановлены.

Строение VMDB и VBLs подробно документировано "LMDDocumentation", находящейся на сайте LINUX-NTFS и потому описывать его здесь нет никакой необходимости (оно слишком громоздко, к тому же крайне маловероятно, что кому-то потребуется восстанавливать секцию config руками).

{{recorever.boot_Image_17.png}}

Рисунок 18 внутри LDM

Для просмотра LDM-базы и архивирования ее содержимого можно воспользоваться утилитой LDM-dump Марка Руссиновича, бесплатную копию которой можно скачать с его сайта (http://www.sysinternals.com/files/ldmdump.zip). Как вариант – можно зарезервировать последний мегабайт физического диска и последний мегабайт всех патриций чей BootID равен 42h любым подходящим дисковым редактором (например, SectorInspector'ом) и сохранить эту информацию на надежном носителе (Zip'е, СD-R/RW), не забывая так же зарезервировать и TOCBLOCK.

При восстановлении удаленных динамических дисков следует учитывать, что: во-первых, журнал изменений на интерфейсном уровне недоступен и выполнить откат легальными средствами операционной системы невозможно. Во-вторых, boot-сектор удаляемых дисков автоматически очищается и восстанавливать его приходится вручную, о чем мы чуть позже и поговорим.

Если размер и тип удаленного динамического диска вам известен (на NTFS-дисках его можно извлечь из копии boot-сектора), просто зайдите в Менеджер Управления Дисками и воссоздайте его заново, от предложения отформатировать раздел любезно откажитесь и восстановите очищенный boot-сектор по методике, описанной ниже.

Как видно, Microsoft тщательно позаботилась о своих пользователях и занималась проектированием структуры динамических дисков на свежую голову, что для нее вообще говоря нехарактерно.

|базовые (Basic) разделы|динамические (Dynamic) разделы|
|основныйраздел/Primary partition|простойтом/Simple volume|
|системныйизагрузочныйраздел/System and boot partitions|системныйизагрузочныйтом/System and boot volumes|
|активный раздел/Activepartition|активныйтом/ Active volume|
|расширенныйраздел/Extended partition|томисвободноепространство/Volume and unallocated space|
|логический диск/Logicaldrive|простойтом/Simple volume|
|набортомов/Volume set|составной том/ Spannedvolume|
|чередующийсянабор/ Stripe set|чередующийся том/ Stripeset|

Таблица 5 терминологическое соответствие динамических и обычных дисков 

===== загрузочный сектор – базовые концепции =====

Первый сектор логического диска носит название //**загрузочного**// (//**boot**//). Он содержит самозагрузочный код (bootstrapcode) и важнейшие сведения о геометрии диска без которых раздел просто не будет смонтирован! Структура boot-сектора определяется архитектурными особенностями конкретной файловой системы, в частности NTFSbootsector выглядит так:

|смещение|размер|назначение|
|0x00|3 bytes|инструкция перехода|
|0x03|8 байт|OEMID – идентификатор|
|0x0B|25 bytes|BPB|
|0x24|48 bytes|Extended BPB|
|0x54|426 bytes|Bootstrap Code|
|0x01FE|WORD|55 AA|

Таблица 6 строение NTFS boot-сектора

В начале всякого сектора расположена трехбайтовая машинная команда перехода на bootstrapcode (обычно EB 52 90, хотя возможны и вариации). Так происходит потому, что при загрузке boot-сектора в память управление передается на его первый байт, а bootstrap код по туманным историческим соображениям был отодвинут в конец сектора (для NTFS верхняя граница составляет 54h байт), вот и приходится прыгать блохой!

С третьего по одиннадцатый байты (считая от нуля) хранится идентификатор производителя, определяющий тип и версию используемой файловой системы (например, "MSDOS5.0  " для FAT16, "MSWIN4.0"/"MSWIN4.1" для FAT32 и "NTFS    " для NTFS). Если это поле окажется искажено, драйвер не сможет смонтировать диск и даже может посчитать его не отформатированным! (примечание: с FAT-дисками Windows 2000 будет работать даже с запорченным OEM ID, чего не скажешь про NTFS).

Следом за идентификатором расположен 25-бйтовый блок параметров BIOS (BIOSParameterBlock или сокращенно BPB), хранящий сведения о геометрии диска (число цилиндров, головок, секторов, размер сектора, кол-во секторов в кластере и т. д.). Если эта информация окажется утеряна или искажена, нормальное функционирования драйвера файловой системы станет невозможным. Причем, если данные число цилиндров/головок/секторов дублирует информацию, содержащуюся в MBR, а при ее утере элементарно восстанавливается описанным выше способом, то размер кластера определить не так-то просто! Позже мы обсудим этот вопрос более подробно, пока же ограничимся следующей табличкой, сообщающий размер кластера NTFS-томов, выбираемой штатной утилитой форматирования по умолчанию (см. таблицу 7)

При выборе размера кластера вручную, Windows 2000 поддерживает следующий модельный ряд: 1 сектор, 2 сектора, 4 сектора, 8 секторов, 16 секторов, 32 сектора, 64 сектора и 128 секторов. Чем больше размер кластер, тем меньше фрагментация и выше предельно адресуемый дисковый объем, но вместе с тем и выше потери от грануляции. Впрочем, ручное задание размеров кластера встречается достаточно редко.

|размер диска|размер кластера|
|< 512MB|1 сектор|
|< 1GB|2 сектора|
|< 2GB|4 сектора|
|> 2GB|8 секторов|

Таблица 7 размер кластера, выбираемый Windows 2000 по умолчанию

К блоку параметров BIOS вплотную примыкает его продолжение – extendedBPB, хранящий номер первого кластера MFT, ее размер в кластерах, номер кластера с зеркалом MFT и некоторую другую информацию. В отличии от FAT16/32, MFT может располагаться в любом месте диска (для борьбы с BAD-секторами это актуально). При нормальном развитии событий MFT располагается практически в самом начале диска (где-то в районе 4 кластера) и если только она не была перемещена ее легко найти глобальным поиском (строка "FILE*" по смещению 0 от начала сектора). При разрушении или некорректном заполнении extendPBP, драйвер файловой системы отказывается монтировать раздел, объявляя его не отформатированным.

Следом за extendPBP идет BootstrapCode, который ищет на диске операционный загрузчик (у Windows NT это ntldr), загружает его в память и передает ему управление. Если BootstrapCode отсутствует, загрузка операционной системы становится невозможной, однако, при подключении восстанавливаемого диска вторым, раздел должен быть прекрасно виден. Порча BootstrapCode кода вызывает перезагрузку компьютера или его зависание.

И завершает boot-сектор уже известная нам сигнатура 55h AAh, без которой он ни за что не будет признан загрузочным.

|смещение|размер|назначение|
|0x00|3 bytes|инструкция перехода|
|0x03|8 байт|OEM ID|
|0x0B|WORD|байт на сектор (для жестких дисков всегда 512)|
|0x0D|BYTE|секторов на кластер|
|0x0E|WORD|кол-во зарезервированных секторов, всегда (?) равно 0|
|0x10|3 BYTES|не используется NTFS и всегда должно быть равно 0|
|0x13|WORD|не используется NTFS и всегда должно быть равно 0|
|0x15|BYTE|медиа дескрпитор для жестких дисков всегда равен 0xF8|
|0x16|WORD|не используется NTFS и всегда должно быть равно 0|
|0x18|WORD|кол-во секторов в треке|
|0x1A|WORD|кол-во головок|
|0x1C|DWORD|кол-во скрытых секторов|
|0x20|DWORD|не используется NTFS и всегда должно быть равно 0|
|0x24|DWORD|не используется NTFS и всегда должно быть равно 0|
|0x28|8 байт|общее количество секторов (totalsector)|
|0x30|8 байт|логический номер кластера, с которого начинается MTF|
|0x38|8 байт|логический номер кластера, с которого начинается зеркало MTF|
|0x40|DWORD|кол-во кластеров на сегмент (File Record Segment)|
|0x44|DWORD|кол-во кластеров на блок индексов (indexblock)|
|0x48|8 байт|серийный номер тома|
|0x50|DWORD|контрольная сумма (0 – не подсчитывать).|
|0x54|426 bytes|Bootstrap Code|
|0x01FE|WORD|55 AA|

Таблица 8 значение полей NTFSboot сектора

===== загрузочный сектор – техника восстановления =====

Осознавая значимость загрузочного сектора, Windows NT при форматировании диска создает его зеркальную копию (правда, только на NTFS разделах). Windows NT 4.0 располагает ее посередине логического диска, а Windows 2000 – в последнем секторе раздела. Если partitiontable цела, просто перейдите в начало следующего раздела и отступите на сектор назад (Windows 2000) или поделите количество секторов логического диска пополам (с округлением в нижнюю сторону) и скажите редактору диска "GO" (Windows NT 4.0).

Если же таблица разделов разрушена, найти копию сектора можно глобальным поиском (ищите строку "NTFS" по смещению 3 от начала сектора). Поскольку, положение копии фиксировано и отсчитывается от начала логического диска, мы можем с абсолютной уверенностью определить границы раздела. Допустим, копия boot'a найдена в секторе 1289724, а поле NumberSectors содержит значение 12289661. Тогда конечный сектор раздела равен 1289724, а стартовый: 1289724 – 12289661 == 63. Поскольку, загрузочный сектор расположен на расстоянии одной головки от partitiontable, что соответствует SectorPerTrack секторам, мы можем восстановить и ее.

В отсутствии копий, boot сектор приходится реконструировать вручную. Это легко. В поле идентификатора производителя заносится строка "NTFS    " (без кавычек, но с четырьмя пробелами на конце). Кол-во секторов в треке и число головок заполняются исходя из текущей геометрии диска. Кол-во скрытых секторов (т. е. секторов расположенных между началом раздела и boot-сектором) равно числу головок. Общее количество секторов в разделе вычисляется на основании его размера (если точный раздел не известен, берите значение с запасом).

Кол-во секторов в кластере определить сложнее (особенно, если диск отформатирован со значением, отличным от принятого по умолчанию). Но ситуация вовсе не безнадежна. Последовательно сканируя файловые записи в MFT, найдите файл с наперед известной сигнатурой. Пусть для определенности это будет NTOSKRNL.EXE. Откройте его аутентичную копию в HEX-редакторе, найдите уникальную последовательность, гарантировано не встречающуюся ни в каких других файлах и расположенную в пределах первых 512 байт от его начала, после чего найдите ее глобальным поиском на диске. Начальный номер кластера вам известен (он содержится в MFT), логический номер сектора тоже (его нашел дисковый редактор). Теперь остается лишь соотнести эти две величины между собой. Естественно, если дисковый ректор найдет удаленную копию NTOSKRNL.EXE (или на диске будут присутствовать несколько файлов NTOSKRNL.EXE), данный метод даст осечку, поэтому полученный результат необходимо уточнить на других файлах.

Логический номер первого кластера MFT равен первому кластеру, в начале которого встретилась строка "FILE*" (конечно, при том условии, что MFT не был перемещен). Штатно Windows выделяет под MFT 10% от емкости раздела, помещая зеркало в середину. Кроме того, ссылка на зеркало присутствует и в самом MFT. Если же он разрушен, переместитесь в середину диска, немного отступите назад и повторите глобальный поиск строки "FILE*" (только, смотрите, не вылетите в соседний раздел!). Первое же найденное вхождение с высокой степенью вероятности и будет зеркалом.

Количество кластеров на сегмент обычно равно F6h, а кол-во кластеров на блок индексов – 01h. Других значений мне встречать не доводилось. Серийный номер тома может быть так же любым – он ни на что не влияет.

Для восстановления отсутствующего (искаженного) bootstrapcode загрузите консоль восстановления и отдайте команду FIXBOOT.

===== заключение =====

Как видно, в восстановлении данных нет ничего мифического и для устранения большинства типов разрушений не требуется никакой квалификации. Если же некоторые места вам не понятны, перечитайте эту статью с дисковым редактором в руках. До сих пор мы говорили о достаточно простых и хорошо известных вещах. Теперь, как следует раскачавшись и освоившись с основными понятиями мы может отправляться в самые дебри NTFS, восстановлению структур которой посвящена следующая статья этого цикла.


