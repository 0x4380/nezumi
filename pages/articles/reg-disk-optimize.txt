====== дефрагментация системного реестра —\\ снаружи и изнутри ======
<sub>{{reg-disk-optimize.odt|Original file}}</sub>

крис касперски, ака мыщъх, a.k.a. nezumi, a.k.a. souriz, no-email

**свежекупленный компьютер работает быстро, но со временем производительность уменьшается, достигая стадии полной деградации уже через несколько лет. продвинутые пользователи знают, что виною тому — фрагментация файловой системы (с которой штатный ****Disk Defrag****, кстати говоря, ни хвоста не справляется), но только гуру догадываются, что реестр также подвержен фрагментации, причем как внешней, так и внутренней и вклад, вносимый ей, в общее падение быстродействия весьма значителен. как вернуть системе вторую молодость без переустановки и прочих радикальных операций?**

{{INLINETOC}}
===== введение =====

Реестр используется постоянно, даже когда мы об этом совсем не подозреваем. Стоит только открыть диалоговое окно "Save As", как система тут же полезет в реестр за стилем, размером/положением окна, перечнем зарегистрированных расширений вместе с сопоставленными им иконками и т.д. и т.п. Словом, даже если дисковая активность отсутствует, жизнь реестра бурлит словно полноводная река, проследить за которой можно с помощью знаменитой утилиты RegMon от Марка Руссиновича, распространяемой на бесплатной основе (www.microsoft.com/technet/sysinternals/utilities/regmon.mspx).

Проведем простой эксперимент: запустим RegMon, вызовем "Блокнот", откроем окно "Сохранить как" и подсчитаем количество обращений к реестру, совершенных за это время. Только сначала пристегнем ремни, чтобы не упасть со стула, потому что обращений этих без малого — 3496!!! (см. рис. 1). Что же тогда говорить о "полновесных" приложениях?! Для достижения максимальной производительности, необходимо добиться, чтобы все ветви реестра располагались как можно ближе друг к другу и магнитная головка не совершала лишних телодвижений. К тому же, реестр грузится в RAM-кэш, и с ростом фрагментации падает не только производительность, но и увеличиваются объем потребляемой памяти!

{{reg-disk-optimize_Image_0.png}}

**Рисунок 1 открытие стандартного "Блокнота" вызывает 3496 обращений к системному реестру!**

В процессе добавления/удаления новых ключей, данные как бы "размазываются" по реестру, образуя многочисленные дыры, увеличивающие как объем дискового файла, так и оперативного буфера, выделенного для его кэширования. Причем, переустановка операционной системы "поверх" проблему не решает, поскольку, использует старый реестр в качестве "скелета", на который цепляется очередная порция ветвей, а оставляющих прежние дыры в неприкосновенности. Реестр продолжает пухнуть словно на дрожжах пока, наконец, пользователь не отформатирует диск и не переустановит Windows с нуля, но это не слишком гуманная операция и к тому же отнимающая массу времени.

{{reg-disk-optimize_Image_1.png}}

**Рисунок 2 по данным компании Systweak быстродействие компьютера (за счет фрагментации реестра) в среднем падает на 50% за полгода эксплуатации (www.systweak.com/aro)**

Мыщъх, переустанавливающий свою любимую W2K всего лишь два раза за последние восемь лет, с фрагментацией реестра знаком не понаслышке и за это время разработал тактику и стратегию борьбы, позволяющую обходится без каких бы то ни было переустановок вообще! Самое интересное, что даже на свежеустановленной системе, поставленной на только что отформатированный диск, реестр уже _фрагментирован_ (спасибо разработчикам инсталлятора!)

===== устройство реестра =====

Реестр является внутренней кухней операционной системы и эта кухня разительным образом отличается в 9x и NT. Поскольку, 9x уже давно труп, мы сосредоточимся исключительно на NT-подобных системах, к числу которых принадлежит, во-первых, сама NT, W2K, XP, Server 2003/2008 и Висла (хотя в Висле наблюдаются некоторые изменения, для понимания материала они некритичны, так что не будем заострять на них внимание).

Физически реестр представляет собой набор дисковых файлов, перечисленных в таблице 1, и блокируемых операционной системы еще на ранней стадии загрузки, а, потому, и неподвластных штатному дефрагментатору.

| **ветвь реестра (****hive****)**|**дислокация на диске**|
|HKEY_CURRENT_CONFIG|System, System.alt, System.log, System.sav|
|HKEY_CURRENT_USER| Ntuser.dat, Ntuser.dat.log|
|HKEY_LOCAL_MACHINE\SAM|Sam, Sam.log, Sam.sav|
|HKEY_LOCAL_MACHINE\Security|Security, Security.log, Security.sav|
|HKEY_LOCAL_MACHINE\Software|Software, Software.log, Software.sav|
|HKEY_LOCAL_MACHINE\System|System, System.alt, System.log, System.sav|
|HKEY_USERS\.DEFAULT|Default, Default.log, Default.sav|

**Таблица 1 локация различных ветвей реестра на диске**

Внутренне, реестр представляет собой двоичное дерево (см. рис. 3), а, всякий кто писал свою собственную реализацию таких структур данных, знает, что дерево состоит из листьев и узлов (ветвей), причем, листья одного узла могут располагаться в различных концах файла реестра. Такое часто случается. Файл реестра заполняется последовательно по мере добавления новых ветвей. Но если мы добавляем лист к ранее созданной ветви, он добывается в конец файла, в то время как родительская ветвь расположена где-то в середине. При удалении ветвей реестра соответствующие им листья лишь помечаются как "удаленные", образуя "дыру". Физической реорганизации данных при этом не происходит! Реестр стремительно увеличивается в размерах и операционная система не имеет никаких механизмов для расчистки мусора!

{{reg-disk-optimize_Image_2.png}}

**Рисунок 3 схематическое устройство реестра**

Поскольку, данные из реестра не только читаются, но и добавляются, причем порядок добавления новых ветвей в общем случае произволен, листья одного узла, вместо того, чтобы быть сгруппированными вместе, оказываются разбросаны по значительной площади. Для увеличения производительности, Microsoft стремится минимилизировать обращения к фалам реестра, кэшируя их в памяти. Проблема в том, что кэширование осуществляется на страничном уровне, а размер одной страницы составляет 4 Кб. То есть, если нам нужно прочесть 10 ветвей реестра (с размером в ~100 байт каждая), разбросанных по всему файлу, мы теряем уже не 10 х 100 == 1000 байт, а 10 х 4096 == 40960, то есть свыше 40 Кбайт оперативной памяти! А ведь системе требуется работать отнюдь не с десятью ветвями и килобайты превращаются в десятки мегабайт! Отсюда — своп, тормоза, etc.

Таким образом, системный реестр подвержен как внешней, так и внутренней фрагментации. Внешняя фрагментация — это порядок расположения кластеров на диске. В идеале, все файлы реестра (перечисленные в таблице 1) должны быть записаны в одной или нескольких непрерывных областях. Если же они разбросаны по поверхности диска как птичий помет — о какой производительности можно говорить?!

Внутренняя фрагментация — это порядок следования узлов и листьев. В идеале, листья, принадлежащие одному узлу, должны быть записаны в непрерывной области файла реестра как можно теснее друг к другу (то есть без "дыр", оставшихся после удаления старых ветвей). Следовательно, дефрагментацию необходимо осуществлять в два этапа, чем мы, сейчас и займемся.

===== борьба с внешней фрагментацией =====

Существует множество дефрагментаторов, умеющих обрабатывать заблокированные файлы (штатный дефрагментатор, как уже говорилось, не входит в их число). Лично мыщъх предпочитает простой, надежный, быстрый и бесплатный "System File Defragmenter" от Марка Руссиновича, (www.microsoft.com/technet/sysinternals/FileAndDisk/PageDefrag.mspx), так же называемый Page Defrag, работающий через "родное" API дефрагментации NTFS-драйвера, что обеспечивает ему совместимость со всеми версиями Windows (включая еще не вышедшие), чего нельзя сказать о дефрагментаторах других производителей, разбирающих базовые NTFS-структуры "вручную" и потому довольно часто превращающие диск в труху, которую потом придется долго и мучительно восстанавливать.

Короче, запускаем "pagedfrg.exe" (внимание! требуются права администратора!) и видим диалоговое окно, перечисляющее заблокированные системные файлы (и файлы реестра в том числе) с указанием числа занимаемых ими кластеров и количеством фрагментов в цепочке (см. рис. 4). Естественно, чем меньше фрагментов — тем лучше, но в любом случае выполнить дефрагментацию не помешает.



{{reg-disk-optimize_Image_3.png}}

**Рисунок 4 System File Defragmenter – бесплатный дефрагментатор реестра от Марка Руссиновича**

В графе "Defragmentation Control" взводим радио-кнопку "Defragment at next boot", заставляя дефрагментатор запуститься при следующей загрузке операционной системы на стадии boot-time (то есть когда стартовало только ядро и основные драйвера) и произвести дефрагментацию всех вышеперечисленных файлов. При желании можно выполнять дефрагментацию и при каждой загрузке (радио-кнопка "Defragment every boot"). Тут уж каждый решает сам за себя. Мыщъх, зачастую не перезагружающий систему по несколько месяцев кряду, не видит между этими двумя пунктами никакой разницы.

Параметр "Defrag abort countdown 3 seconds" позволяет задавать промежуток времени в течении которого дефрагментацию будет можно отменить нажатием любой клавиши. Если мы твердо уверены в своих намерениях и не собираемся ничего отменять, можно сбросить этот параметр в ноль, чтобы понапрасну не терять драгоценного времени.

Давим на "ОК" и… ничего не происходит?! Спокойно! Без паники! Именно так все и должно быть! Дефрагментор запустится только при следующей загрузке системы, так что идем в меню "Пуск", выбираем там соответствующий пункт и терпеливо ждем. Впрочем, долго ждать не придется.Привычный процесс загрузки прервется чужеродным сообщением дефрагментатора (см. рис. 5), сообщающего сколько и чего было дефрагментировано.

{{reg-disk-optimize_Image_4.png}}

**Рисунок 5 дефрагментация реестра в boot-time**

К сожалению, за один проход Page Defrag дефрагментирует лишь наиболее фрагментированные файлы, да и то не до конца, а потому для достижения максимальной производительности эту процедуру следует повторять несколько раз, добиваясь, чтобы все файлы реестра располагались в одном фрагменте (при этом, возможно, придется предварительно расчистить дисковое пространство, выкидывая оттуда все лишнее. по спецификациям на NTFS-драйвер, для нормальной работы дефрагментатора должно быть свободно по меньшей мере 13% дискового пространства, а лучше — от 20%-30% и выше. конечно, это довольно суровые цифры, особенно для владельцев небольших дисков, забитых до отказа, но, увы, такова жизнь).

На этой возвышенной ноте будем считать, что со внешней дефрагментацией реестра покончено и пора браться за внутреннюю.

===== борьба с внутренней фрагментацией =====

Прежде чем приводить внутренние структуры реестра в полный порядок, крайне желательно запустить Reg Cleaner или любую другую утилиту подобного типа, удаляющую неиспользуемые ветви и прочий поганый мусор. Сама по себе чистка не сжимает реестр и не увеличивает производительности (поскольку, на месте удаленных ветвей остаются дыры), однако, в совокупности с дефрагментацией она дает впечатляющий результат.

Также рекомендуется проверить реестр на предмет различных ошибок, чем занимается целый легион утилит, в том числе и условно-бесплатная "Advanced Registry Optimizer/Registry Cleaner"от уже упомянутой компании Systweak (http://www.systweak.com/aro), бесплатно-демонстрационная версия которой обнаружила на мыщъхином компьютере свыше трех тысяч ошибок (см. рис. 6), но согласилась пофиксить только двадцать из них, а за исправление остальных — надо платить (или хачить).

{{reg-disk-optimize_Image_5.png}}

**Рисунок 6 сканирование системного реестра на предмет ошибок утилитой Advanced Registry Optimizer**

Помимо прочих полезных инструментов для работы с реестром, "Advanced Registry Optimizer" включает в себя и внутренний дефрагментатор. Быстрый, но не самый лучший. К тому же не выдающих никаких внятных отчетов и тут лучше воспользоваться условно-бесплатной утилитой "Registry Defragmentation" (http://www.elcor.net/rdefrag.php) от компании Elcor,поддерживающей все операционные системы: от 95 до Вислы включительно. Благодать длится 21 день, после чего коммунизм заканчивается и дальше приходится действовать по обстоятельствам. (Кстати, это одна из немногих известных мне утилит, умеющая дефрагментировтаь ветвь Security, правда, не без выдачи предостерегающего предупреждения, что в процессе дефрагментации может возникнуть косяк и система рухнет, впрочем, у меня так и не рухнула ‑ сколько бы мыщъх над ней не издевался).

Программа не только приводит реестр в порядок, но так же выдает симпатичный отчет (см. рис. 7), убедительно показывающий чем мы ей обязаны (может быть, и вправду стоит заплатить?!). К сожалению, сильно фрагментированного реестра мыщъх так и не нашел, а потому приведенный результат к категории впечатляющих и срывающих крышу явно не принадлежит, но стоит поработать с компьютером несколько месяцев, как левое окно (состояние реестра до дефрагментации) будет буквально усеяно красными квадратиками, изображающими фрагментированные узлы!

{{reg-disk-optimize_Image_6.png}}

**Рисунок 7 дефрагментация системного реестра утилитой Registry Defragmentation**

Другая полезная утилита данного класса — "RegCompact Pro" от компании ExperimentalScene (http://www.experimentalscene.com/). Демонстрационная версия работает только 7 дней. Ветвь Security и выдача отчета о проделанной работе — поддерживаются, правда, правда, наглядность отчета далеко не на высоте (см. рис. 8). Кстати, в работе с программой есть одна хитрость — при первом же запуске она ломанется в Интернет, требуя прямого соединения с сетью (или proxy) и передавая регистрационные данные, которые еще заполнить надо! А нам в лом! И вообще, право на тайну личности никто не отменял, вот мы и жмем на "Cancel", но вместо ожидаемого отказа работать… неожиданно попадаем в основное окно программы! Оказывается, что Интернет ей не так уж и сильно нужен. Достаточно нажать "Activate" и ввести серийный номер (полученный известным путем), и хотя мы останемся незарегистрированными пользователями (то есть без поддержки), нам, хакерам, к этому не привыкать!

{{reg-disk-optimize_Image_7.png}}

**Рисунок 8 дефрагментация реестра с помощью программы "RegCompact Pro" от компании ExperimentalScene**

===== реестр в руинах =====

Дефрагментация реестра (особенно внутренняя) — довольно рискованная операция. После такого мероприятия можно и не загрузится, а это уже сплошной ахтунг! Вообще-то, в состав Advanced Registry Optimizer и Registry Defragmentation входят утилиты резервирования реестра (Registry Backup) для его последующего восстановления, если что-то пошло не так. Аналогичной функциональностью обладает и штатный Microsoft Backup. Однако, все это GUI-приложения, нуждающиеся в графическом интерфейсе. Если же система "падет" еще на ранних стадиях загрузки — весь этот зоопарк отдыхает.

Конечно, можно просто переустановить Windows с нуля, но… вопрос даже не в том, сколько времени это займет. Если использовались атрибуты шифрования для файлов (поддержка которых появилась начиная с W2K), то после переустановки они окажутся недоступны, даже если мы создадим учетные записи с идентичными именами и паролями. А все потому, что хитрая Microsoft генерирует для каждого пользователя специальный ключ, хранящийся в реестре и погибающий вместе с ним. Так что переустановка ничего не решает.

Мыщъху известно два выхода из этой ситуации (отказ от дефрагментации — не предлагать). Первое — установить "теневое" зеркало диска с помощью утилит от Norton'а или Acronics'а, что "скушает" довольно много дискового пространства, но… зато в любой момент у нас будет возможность выполнить "откат", восстанавливая исходный реестр из дымящихся руин вместе со всеми файлами, которые мы успели изменить за это время, что, согласитесь, не есть хорошо и вообще полный бэд.

Вариант намбер ту: перед дефрагментацией заходим в систему с правами администратора (внимание! _не_ запускаем FAR с правами администратора из под обычного пользователя! нам нужен _чистый_ администратор). Заходим в директорию "Documents and Settings" и копируем оттуда все файлы ntuser.dat (хранящие HKEY_CURRENT_USER) в какое-нибудь надежное место, например, на ZIP или CD/DVD-RW, естественно, не забывая какой ntuser.dat какому пользователю принадлежит. Скопировать ntuser.dat самого администратора не получится, поскольку, он заблокирован системой. Ничего не поделаешь! Приходится заводить еще одного пользователя из группы администраторов, логниться под его именем и копировать ntuser.dat "настоящего" администратора.

Теперь (не выходя из администратора), запускаем Microsoft Backup, набирая в командной строке "ntbackup.exe". Далее во вкладке "Архивация" взводим галочку напротив пункта "Состояние системы" и, указав путь к архиву, нажимаем на кнопку "Архивировать". Архив (занимающий порядка четверти гигабайта) следует так же перебросить на ZIP или другой носитель по вкусу.

ОК. Теперь, когда наша задница капитально прикрыта от всяких там напастей, выполняем дефрагментацию реестра и в случае неуспеха приступаем к восстановительным работам. Снимаем с компьютера системный диск и подключаем его вторым к системе с живой NT/W2K/XP/Висле (впрочем, на счет Вислы я не уверен). Вставляем ZIP/CD/DVD в привод и копируем все ntuser.dat файлы туда, откуда они были взяты на сохранение.

Следующая фаза операции: запускаем (на здоровой машине) ее собственный Microsoft Backup, переходим ко вкладке "Восстановление" и подсовываем архивный файл, созданный перед крахом нашей основной системы. Теперь, внимание на экран!!! В графе "Восстанавливать файлы в:" выбираем пункт "Альтернативное размещение", а строкой ниже указываем путь к этому самому альтернативному размещению (например, "C:\TEMP\Unpack") и после нажатия на кнопку "Восстановить" Microsoft Backup распакует архив, поместив все файлы в "C:\TEMP\Unpack\Реестр", откуда мы копируем их в каталог "\WINNT\system32\config\" порушенной машины.

Вот, собственно, и все. Отдираем диск и прикручиваем его обратно. Загружаемся. Если все было сделано правильно, система стартует нормально и никаких следов разрушений в упор не наблюдается. Так что можно продолжать эксперименты с дефрагментацией реестра и дальше. Естественно, всякий новый дефрагментатор лучше всего предварительно опробовать на виртуальной машине, чтобы потом не трахаться с восстановлением основной системы.

===== заключение =====

Выигрыш от дефрагментации реестра в значительной мере определяется количеством имеющейся оперативной памяти (если памяти много, туда можно загрузить даже сильно фрагментированный реестр практически без ущерба для производительности). К тому же, если на компьютере работают, а не играются в добавление/удаление новых программ, то реестр фрагментируется крайне медленно и с такой системой можно проработать не один год, без каких бы то ни было проблем.

К сожалению, установка заплаток безопасности фрагментирует реестр (иногда — весьма значительно) и потому совсем без дефрагментаторов никому не обойтись. Косвенно оценить разницу до и после дефрагментации можно с помощью штатного диспетчера задач (вызываемого комбинацией клавишей <Alt-Shift-Esc>), замеряя количество потребляемой памяти сразу же после загрузки системы. После дефрагментации сильно фрагментированного реестра оно зачастую сокращается на несколько десятков мегабайт. Ну и плюс скорость загрузки.

С другой стороны, чрезмерное увлечение дефрагментаторами ни к чему не ведет и эту операцию следует выполнять приблизительно раз в сезон, а если за минувшее время никаких новых программ не устанавливалось — то и реже. Однако, следует помнить, что некоторые программы довольно интенсивно работают с реестром, создавая и удаляя большое количество ветвей в ходе их нормальной эксплуатации. Так что универсальных рецептов здесь нет и оптимальный период дефрагментации лучше всего подбирать экспериментально.

{{reg-disk-optimize_Image_8.jpg}}

**Рисунок 9 мыщъх дефрагментирует системный реестр, тупо уставившись на экран**

===== >>> врезка ссылки по теме =====

  * **Inside Windows NT Disk Defragmenting:**
    * статья Марка Руссиновича, рассказывающая о работе дефрагментатора встроенного в штатный драйвер NTFS.SYS (на английском языке): http://www.microsoft.com/technet/sysinternals/information/diskdefragmenting.mspx;
  * **Inside the Registry**:
    * статья из Windows NT Magazine, подробно описывающая структуру, принципы работу и внутреннею организацию системного реестра (на английском языке): www.microsoft.com/technet/archive/winntas/tips/winntmag/inreg.mspx?mfr=true;
  * **Windows registry information for advanced users**:
    * еще одна статья из MSDN, посвященная устройству системного реестра, ориентированная на продвинутых пользователей (на английском языке): http://msdn2.microsoft.com/en-us/library/ms724877.aspx;

