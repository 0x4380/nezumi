====== linice ======
<sub>{{linice.odt|Original file}}</sub>

====== основы термоядерной отладки с linice ======

крис касперски ака мыщъх, no-email

**достойных отладчиков ядерного уровня и под ****windows**** немного, а на ****linux**** их можно пересчитать по пальцам одной руки, да и те большей частью сырые, недоделанные или же позаброшенные, мхом позаросшие… сегодня мы поговорим о самом популярном и наиболее интересном из них — ****linice****.**

===== введение =====

Как уже можно догадаться из названия, **linice** – это неофициальный "порт" легендарного soft-ice под linux, сохранивший интерфейс, систему команд и большинство возможностей последнего — всплытие по горячей клавише (в linice это <CTRL‑Q>), установка аппаратных точек останова на _все_ функции и системные вызовы, просмотр GDT/LDT/IDT, _физических_ страниц памяти, плюс возможности, позаимствованные из GDB (вызов произвольной функции командой CALL, сохранение/восстановление контекста регистров, внутренние переменные и т. д.).

В отличии от большинства других отладчиков, работающих через нереентерабельный и легко обнаруживаемый защитами механизм ptrace (windows-аналогом которого является DEBUG_PROCESS, используемый прикладными отладчиками), linice использует "нативную" трассировку, такую же как в soft-ice, что позволяет обоим отладчикам отлаживать круто защищенные программы, с которыми другие уже не справляются.

{{linice_Image_0.png}}

Рисунок 1 внешний вид отладчика linice

На самом деле это никакой не порт (отсюда и кавычки), а независимый проект, написанный с нуля и распространяющийся в исходных текстах на бесплатной основе (от soft-ice там только вдохновение). Основная часть кода, предназначенная для 2.4 ядра, была написана немецким хакером Гораном Девиком (GoranDevic, <author@linice.com>), однако, поддержкой 2.6 ядра занимались уже совсем другие люди: DanielReznick, PeterK. и CarlosManuelDuclosVergara. А наш соотечественник — Олег Худаков — переписал ассемблерные файлы с NASM'а на GCC.

Исходные тексты лежат на официальном сайте проекта — http://www.linice.com, там же находится документация, короткий FAQ и ссылка на форум http://groups.google.com/group/linice, насчитывающий 35 зарегистрированных участников и 33 топика, последний из которых датирован 12 июнем 2006 года (т. е. имеет возраст свыше трех месяцев). Готовые бинарные сборки отсутствуют.

{{linice_Image_1.png}}

Рисунок 2 официальный сайт linice

Создатели проекта открыли свой собственный аккаунт на sourceforge, но поленились выложить на него какие бы то ни было файлы, предоставив на обозрение всего лишь 3 screenshot'а весьма похабного качества: https://sourceforge.net/projects/linice

{{linice_Image_2.png}}

Рисунок 3 linice на sourceforge

===== системные требования =====

Последняя версия linice носит номер 2.6 и датируется 28 июлем 2005 года, полностью поддерживая 2.4.xlinux-ядро и консольный VGA-режим. С более новыми ядрами наблюдаются серьезные проблемы и 2.6.x ядро поддерживается лишь в ограниченном режиме.

Отладчик разрабатывался и тестировался под Debian 2.6, совместимость с остальными дистрибутивами не гарантируется, вынуждая прибегать к бубну, но не в некоторых случаях не помогает и бубен. Вообще-то, держать на своей машине Debian только для того, чтобы работать с linice – это вполне нормально. Давным-давно, когда реализации soft-ice для NT еще не существовало, многие хакеры инсталлировали 9x только для того, чтобы ломать программы, хотя сами сидели под NT.

Поскольку, охватить все тонкости установки linice в рамках одной статьи практически нереально, мыщъх ограничится описанием процесса компиляции и запуска linice под одним конкретным дистрибутивом KNOPPIX 3.7 с ядром 2.4.1 в консольном VGA-режиме.

{{linice_Image_3.jpg}}

Рисунок 4 дистрибутив KNOPPIX'а, совместимый с linice

linice поддерживает ACPI и многопроцессорные машины, но плохо дружит с X'ми, особенно на видео-картах отличных от nVIDIA, а в 24-битную глубину цветности он вообще не врубается, "переваривая" только 8-, 16- и 32 бит/на пискельные режимы, поэтому, отладку X-приложений удобнее вести через удаленный терминал, подключенный по COM-порту по протоколу VT100, при этом локальная клавиатура так же будет работать с linice!

Кстати, о клавиатурах. Поскольку, linice взаимодействует с оборудованием напрямую, то USB-клавиатуры им не поддерживается (разработчикам было лень тащить за собой USB-стек). Используйте стандартную PS/2 (DIN) клавиатуру, а если таковой не имеется — выключите поддержку всех USB-устройств в linux'е, заставляя BIOS эмулировать PS/2 клавиатуру, понятную linice.

Под виртуальными машинами (и, в частности, VM Ware 4.5) linice либо вообще не загружается, либо загружается, но не реагирует на клавиатуру, либо срывает виртуальной машине крышу, вынуждая нас работать на "живом" железе, что не есть хорошо, однако, технологии эмуляции непрерывно совершенствуется и есть надежда, что через некоторое время эта проблема будет решена.

{{linice_Image_4.png}}

Рисунок 5 реакция VMWare на попытку запуска linice

===== компиляция и конфигурирование linice =====

Скачиваем gzip-архив исходных текстов http://www.linice.devic.us/linice-2.6.tar.gz, занимающий чуть меньше мегабайта, распаковываем его на диск, заходим в каталог ./docs, вникаем в readme откуда узнаем, что сборка отладчика под 2.4 ядро осуществляется так:

# cdbuild

# ./make_bin-2.4

# cd ../bin

# makeclean ; make

Листинг 1 сборка linice под 2.4 ядро

Однако, перед запуском make необходимо открыть файл ./bin-2.4/Makefile и отредактировать строку "TARGET" в соответствии с конфигурацией и архитектурой целевой платформы. В частности, на ACPI-машинах с многоядерными или HyperThreading-процессорами она будет выглядеть так:

TARGET = -DSMP -DIO_APIC

Листинг 2 конфигурирование отладчика

После завершения компиляции в каталоге ./bin появятся множество файлов и каталогов, но значимыми из них являются только: **lin****s****ym** – загрузочный модуль отладчика, **linince****.****dat** – файл конфигурации, **xice** – поддержка X'ов, при работе в текстовом режиме его можно удалить; **./****linice****_2.4.27/****linice****.****o** – загружаемый модуль ядра, содержащий непосредственно сам отладчик.

Собрав минимально работающий комплект, неплохо бы дособирать и все остальное — демонстрационные отладочные примеры, находящиеся в каталоге ./test и компилируемые скриптом compile, а так же модуль расширения (по-нашему плагин), лежащий в каталоге ./ext, собираемый командой make и загружаемый командой insmod. Никакой пользы от него нет, но изучив исходный текст, мы сможем писать свои собственные модули, расширяющие функциональность linice.

{{linice_Image_5.png}}

Рисунок 6 процесс сборки linice

===== загрузка системы и запуск отладчика =====

При загрузки KNOPPIX'а cLiveCD в нижней строке экрана появляется приглашение "boot:" где необходимо ввести "**knoppix ****2**** vga****=****normal**". Cheat-код "knoppix" выбирает ядро 2.4 (автоматически загружаемое по умолчанию, поэтому "knoppix" можно опустить), "2" – блокирует загрузку X'ов, а "vga=normal" устанавливает стандартный vga режим с разрешением 80x25.

{{linice_Image_6.png}}

Рисунок 7 загрузка KNOPPIX'а с LiveCD

Дождавшись завершения загрузки, говорим "su", затем "passwd" и вводим новый пароль для root'a, под которым тут же заходим в систему, воспользовавшись командой "login". Если этого не сделать, попытка запуска linice закончится сокрушительным провалом с воплем о "segmentationfault".

{{linice_Image_7.png}}

Рисунок 8 загрузка KNOPPIX'а с жесткого диска

При загрузке KNOPPIX'а с жесткого диска (на который его можно установить командой "sudo knoppix-installer", набранной в окне терминала из-под LiveCD сессии), появится стартовое меню со списком доступных ядер. Выбираем "Linux(2.4)-1" и нажимаем <TAB> для задания параметров загрузки: "** 2 ****vga****=****normal**". Слово "knoppix" писать не нужно, поскольку ядро уже выбрано и так. После завершения загрузки даем команду "login" и входим в систему под root'ом (предполагается, что аккаунт был создан ранее).

{{linice_Image_8.png}}

Рисунок 9  KNOPPIX, загруженный без X'ов в консольном VGA-режме

Запуск отладчика осуществляется командой "./linsym -i", после чего отладчик немедленно появляется на экране. Если же этого не происходит, попробуйте указать ключ "‑‑verbose 3" для вывода диагностических сообщений.

{{linice_Image_9.png}}

Рисунок 10 процедура запуска отладчика

Одной из причин отказа в загрузке может быть отсутствие файла /boot/System.map, содержащего адреса ядерных функций. Загрузка провалится и в том случае, если содержимое System.map не соответствует текущему ядру, что может произойти, например, при его рекомпиляции. Некоторые составители дистрибутивов либо вообще не включают System.map (полагая, что это усилит безопасность системы, т. к. rootkit'ам будет сложнее осуществить перехват syscall'ов), либо кладут сюда что-то совершенно левое и вообще непонятно откуда взятое. В таких случаях достаточно просто перекомпилировать ядро, указав отладчику путь к файлу System.map с помощью ключа "-m", если он расположен не в /boot, а где-нибудь в другом месте. Таким образом и безопасность не пострадает и linice сможет работать!

{{linice_Image_10.png}}

Рисунок 11 linice запущенный в консольном VGA режиме

Возврат из отладчика в систему происходит по <F5> или команде "x <ENTER>". Комбинация <CTRL-Q> вызывает отладчик из любой программы, однако, вовсе не факт, что мы очутимся в ее контексте, ведь linux — многозадачная система, переключающая процессы один за другим, а команды "ADDR" (переключающей контексты) в "лексиконе" linice все еще не существует и когда она появится — неизвестно, поэтому приходится хитрить, устанавливания точки останова на системные вызовы, используемые конкретной программой или врываясь в процесс по методу INT 03h, о чем мы сейчас и поговорим.

За выгрузку отладчика (если его действительно хочется выгрузить) отвечает ключ "-x", переданный все тому же linsym'у.

===== основы работы с linice =====

Для тех, кто уже работал с soft-ice, освоение linice не представит никакой проблемы. Здесь используются все те же команды: "D" – дамп памяти, "E" – редактирование памяти, "T" – пошаговая трассировка, "P" – трассировка без захода в функции, "R" – просмотр/модификация регистров, "BPM/BPX" – установка точки останова на доступ/исполнение памяти и т. д. Полный перечень команд содержится как во встроенной справке, вызываемой по "HELP" (причем, "HELP имя_команды" выдает дополнительную информацию по команде), так и в штатной документации.

Давайте нажмем <CTRL-Q> и пороемся в списке процессов, выводимых на экран командой "PROC", причем текущий процесс выделяется голубым цветом:

:PROC

PIDTSSTaskstateuidgidname

 10000 C1C3E000SLEEPING00init

 20000 F7EE8000SLEEPING00keventd

 30000 F7EE2000SLEEPING00ksoftirqd_CPU0

 40000 F7EE0000SLEEPING00ksoftirqd_CPU1

 50000 F7ED0000SLEEPING00kswapd

 60000 F7EAA000SLEEPING00bdflush

 70000 F7EA8000SLEEPING00kupdated

 560000 F6A36000SLEEPING00kjournald

**10060000 F7A34000RUNNING00automount**

10130000 F68E6000SLEEPING00cupsd

…

11050000 F6DDE000SLEEPING00mc

11060000 F6DD4000SLEEPING00cons.saver

Листинг 3 вывод списка процессов на экран

Процессы это, конечно, хорошо, но как же все-таки нам отлаживать программы? Самое простое – воткнуть в точку входа машинную команду CCh, соответствующую инструкции INT 03h, предварительно записав содержимое оригинального байта. Это можно сделать любым hex-редактором, например, неоднократно упоминаемом мыщъх'ем HTE.

{{linice_Image_11.png}}

Рисунок 12 втыкаем CCh в начало файла в hex-редакторе HTE

Загрузив файл в редактор, нажимаем <F6> (mode), выбираем elf/image, подгоняем курсор к "entrypoint:", давим <F4> (edit) и, изменяем первый байт на CCh, сохраняем изменения по <F2> (save) и выходим. При запуске пропатченной программы linice немедленно всплывает, потревоженный исключением, сгенерированным CCh, после которого EIP указывает на конец CCh.

0023:080482C0CCint3

**0023:080482C1EDineax, dx**

0023:080482C25Epopesi

0023:080482C389E1movecx, esp

Листинг 4 состояние программы, c пропатченной точкой входа, в момент всплытия отладчика

Курсор указывает на инструкцию "in eax,dx" (EDh), представляющую собой "осколок" от пропатченной команды "xor ebp,ebp" (31h EDh). Теперь (по идее) мы должны восстановить оригинальный байт, заменив CCh на 31h, уменьшить регистр EIP на единицу и продолжать трассировку в обычном реже.

Да вот не тут-то было!!! linice это, конечно, порт, но… только очень сырой и модифицировать память страничного имиджа он _не_ умеет, даже если предварительно открыть кодовый сегмент на запись. Ни "E" (редактирование), ни "F" (заполнение), ни "M" (копирование памяти) _не_ работают!!! Зато работает запись в стек и нам, хакерам, этого вполне достаточно.

Запоминаем текущее значение регистра EIP, копируем пропатченную машинную команду на вершину стека, восстанавливаем там байт CCh, передаем на нее управление, меняя значение EIP, выполняем ее, совершив единичный акт трассировки и возвращаем EIP на место, то есть на _следующую_ машинную команду:

:? eip; узнаем EIP

Hex=080482C1Dec=0134513345

; смотрим, что находится на вершине стека (из чистого любопытства)

:d esp-10

0018:BFFFEFC0 C0 82 04 08 00 00 00 00 5D 0C 00 40 DC EF FF BF

; копируем пропатченную машинную команду на вершину стека

; число 10h - максимально возможный размер машинной команды на x86

:m eip-1 L 10 esp-10

; смотрим как изменился стек

:d esp-10

0018:BFFFEFC0 CC ED 5E 89 E1 83 E4 F0 50 54 52 68 F0 85 04 08

; ага! стек действительно изменился, самое время править CCh на 31h

:e esp-10 31

Edit immediate data not implemented yet.

; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

; опс! непосредственное присвоение данных в linice не реализовано

; но мы можем отредактировать дамп в интерактивном режиме (так же как в soft-ice)

; или дать команду "Fesp-10 L 1 31", только имейте ввиду, что в отличии от soft-ice

; отладчик linice _не_ обновляет окно дампа, поэтому, после выполнения команды F

; может показаться, что результата нет, на самом деле это не так, стоит только

; обновить дамп командой "D esp-10" и все встанет на свои места

; передаем управление на команду, скопированную в стек

:r eip (esp-10)

reg: eip = BFFFEFC0

; запоминаем это значение регистра EIP

:t; совершаем единичный акт трассировки

0023:BFFFEFC2  5Epopesi

;  ^^^^^^^^

; как мы видим регистр EIP увеличился на 2 (BFFFEFC2h - BFFFEFC0h) = 02h

; следовательно адрес следующей команды равен: 080482C1h - 01h + 02h = 080482C2h,

; где 080482C1h — начальное значение EIP при входе в программу, а 01h - размер INT 03h

:reip 80482C2; устанавливаем EIP на команду, следующую за пропатченной инструкцией

reg: eip = 80482C2

; - - - продолжаем трассировку в обычном режиме - - -

Листинг 5 восстановление оригинального байта, замененного инструкцией INT 03h

Вот такие пляски с бубном устраивать приходится. А что поделаешь?! Ладно, с загрузкой программ в отладчик мы разобрались, теперь растерзаем точки останова на системные вызовы и ядерные функции.

Команда "exp" выводит имена, экспортируемые ядром (см. листинг 6), любое из которых может непосредственно фигурировать в выражениях, например, "bpx do_bkr" эквивалентно "bpx C012C9E8":

:exp

kernel

C0320364mmu_cr4_features

C02AC3A4acpi_disabled

C02AC8A0i8253_lock

…

C012BDA8do_mmap_pgoff

C012C764do_munmap

C012C9E8do_brk

C011E990exit_mm

C011E69Cexit_files

Листинг 6 выводимен, экспортируемых ядром

С системными вызовами приходится сложнее. Непосредственной поддержки со стороны linice здесь нет (а ведь ей полагается быть, учитывая специфику linux), поэтому эту штуку приходится делать руками и хвостом.

Таблица системных вызов, как известно, представляет собой массив двойных слов, начинающийся с адреса sys_call_table (эта переменная экспортируется ядром).

:dd; переводим отладчик в режим отображения двойных слов

:dsys_call_table; выводим таблицу на экран

0018:C02AB6A8 C0126ACC F8932650 F89326A0 C013DC10

0018:C02AB6B8 C013DD18 C013D5C8 C013D724 C011F3BC

0018:C02AB6C8 C013D664 C014A8E0 C014A3B4 F893020C

Листинг 7 таблица системных вызовов

Каждый элемент таблицы соответствует своему системному вызову, а каждый вызов имеет свой номер, который можно узнать заглянув в файл /usr/include/sys/syscall.h, но лучше это делать не под linux, где никаких непосредственных номеров нет, а позаимствовать тот же самый файл из BSD – все равно номера основных системных вызовов на всех системах совпадают. В частности, системный вызов open проходит под номером 5.

{{linice_Image_12.png}}

Рисунок 13 номера системных вызовов

Чтобы установить точку останова на "open" необходимо узнать его адрес, находящийся в 5'ом двойном слове таблицы системных вызов, считая от нуля и равный (в данном случае) C013D5C8h.

:bpxC013D5C8; устанавливаем точку останова на системный вызов open

:x; выходим из отладчика

…

# открываем какой-нибудь файл

…

:Breakpoint due to BPX 01

; ^^^^^^^^^^^^^^^^^^^^^^^

; отладчик тут же всплывает, сообщая нам об этом

:proс; даем команду proc, чтобы убедиться, что мы вклинились в свой процесс

PIDTSSTaskstateuidgidname

10490000F6364000SLEEPING00getty

**11450000F61CC000SLEEPING00mc**

11460000F614A000SLEEPING00cons.saver

Листинг 8 установка точки останова на системный вызов open

Таким путем легко "вклиниваться" в уже запущенные процессы, устанавливая точки останова на используемые ими системные вызовы, а так же совершать множество других вещей, жизненно важных для взлома.

===== заключение =====

Несмотря на свою откровенную сырость, linice вполне пригоден для отладки защищенных приложений, хотя сплошь и рядом приходится прибегать к обходным решениям, которые в нормальных отладчиках осуществляются на автомате. Поэтому, linice отнюдь не заменяет gdb, а всего лишь дополняет его.


