====== философия Microsoft 2003 ResourceKit ======
<sub>{{S2k3rk.odt|Original file}}</sub>

крис касперски ака мыщъх, a.k.a. nezumi, a.k.a. souriz, a.k.a. elraton, no-email

**в штатный комплект поставки операционных систем семейства ****UNIX ****традиционно входит огромное количество утилит на все случаи жизни и администратору не приходится рыскать по сети в поисках решений от сторонних разработчиков (как правило, платных). ****Microsoft ****же, долгое время стремившаяся превратить ****Windows NT ****в тостер, управляемый посредством мыши, постепенно осознает порочность такого подхода, начинаем перенимать лучшие черты ****UNIX'****а. большое количество полезных утилит можно найти в папке ****Support Tools ****на дистрибутивном диске и еще больше их содержится в ****Resource****Kit'****ах, которые можно бесплатно скачать с сайта компании. нужны ли они администратору? и если да, то зачем?**

{{INLINETOC}}
===== введение =====

Самый популярный на сегодняшний день набор — Microsoft Resource Kit 2003 (выпущенный 28 апреля 2003 года) несет на своем борту порядка двухсот утилит, скрипты и документацию. Несмотря на свой скоромный размер (~12 Мбайт) это невероятно мощный инструмент, полное описание которого потребовало бы отельной книги, даже если расходовать не более страницы текста на одну утилиту мы уже получим солидный том, а ведь многие утилиты требуют десятков страниц описания!

Просто перечислять, что есть в MS Resource Kit 2003 – глупо и неинтересно. Проще скачать несчастные 12 мегабайт и заглянуть в хелп. Поэтому, автор решил изменить тактику, сместив центр смысловой тяжести в сторону философских концепций, продемонстрировав их на нескольких вполне конкретных примерах.

===== в охоте за Recourse Kit =====

MS Resource Kit можно свободно скачать с сервера Microsoft по следующей ссылке: http://www.microsoft.com/downloads/details.aspx?FamilyID=9D467A69-57FF-4AE7-96EE-B18C4790CFFD&displaylang=en, причем, проверка подлинности при этом не требуется. Чтобы не запоминать абракадабру столь длинного URL (когда же, наконец, Microsoft наведет порядок в своем файловом хозяйстве), проще набрать в Google: "Microsoft Resource 2003" и первая же ссылка приведет нас к цели (можно, конечно, зайти на download-центр Microsoft'а, но там такая структура, что блуждать можно часами, ходя по закольцованным ссылкам кругами, каждый раз возвращаясь на стартовую страницу вместо искомой).

Пусть название Kit'а не введет вас в заблуждение. Он работает не только на MS Server 2003 (хотя, главным образом, конечно, "заточен" под него), но так же и под XP, W2K, а некоторые (впрочем довольно немногочисленные) утилиты функционируют даже под Windows 9x/Me, но вот для самой установки требуется как минимум XP, на W2K комплект Resource Kit 2003 ставится в упор не желает, но если под рукой есть Server 2003, то можно инсталлировать его туда, а на W2K/9x/Me перенести простым копированием папки Microsoft Resource Kit 2003 (имя которой, естественно, может быть любым). При этом нужно не забыть скопировать файл помощи, закинутый установщиком в C:\WINDOWS\help\rktools.xml (хотя настоящие администраторы справок не читают, предпочитая действовать методом тыка).

{{s2k3rk_Image_0.png}}

**Рисунок 1 отсюда можно бесплатно скачать Microsoft Resource Kit 2003**

===== философия Resource Kit =====

Подавляющее большинство программ, входящих в состав MS Resource Kit – это утилиты командной строки. Зачем они нужны в век графических интерфейсов и быстрых каналов, позволяющих управлять сервером удаленно с помощью мыши без всяких тормозов? Управлять, конечно, можно, но вот если подсчитать — сколько щелчков мыши приходится совершать каждый раз, чтобы выполнять _один_ и _тот_ _же_ набор типовых задач? Сколько времени приходится проводить в ожидании завершения операции A, после которой следует запустить операцию B и, наконец, кто не матерился, вручную переписывая отчеты, сгенерированные в графических окнах без возможности выделения текста и копирования его в буфер обмена?!

Командная строка — это не просто черный средневековый экран с мерцающим курсором — средством инквизиции. Это прежде всего командный язык. Не то, чтобы сильно развитый (с UNIX'ом не сравнить), но поддерживающий базовые конструкции: условия, циклы, переменные.

Только вместо операторов у нас набор исполняемых файлов, подавляющее большинство из которых может принимать данные с любого источника: с клавиатуры (именуемой стандартным вводом), дискового файла или результатов деятельности другой программы.

Автоматизация управленческой деятельности — великая вещь! Командные файлы позволяют выполнять сложные операции нажатием всего лишь одной клавиши или запускаться через системный планировщик по расписанию, работая автономно без всякого вмешательства администратора. Графические же программы страдают хронической тупостью и задают кучу глупых вопросов в стиле: а вы уверены в том, что не уверены? Шутки -шутками, графический проводник Windows не поддерживает и 10% функций, поддерживаемых ядром NT, что создает _огромные_ проблемы. Хотите конкретный пример? Пожалуйста!!!

{{s2k3rk_Image_1.png}}

**Рисунок 2 справка по Microsoft Resource Kit 2003**

===== подсчет жестких ссылок с помощью HLScan =====

Файловая система NTFS выгодно отличается от FAT тем, что поддерживает жесткие ссылки (hard link'и), кстати говоря, поддерживаемые всеми никсовыми файловыми системами. Иерархическая организация директорий хорошо работает только в теории, а на практике… Вот, допустим, у нас имеется каталоги: Books/Coding (книги по программированию) и Books/Unix (книги по UNIX'ам). В какой каталог мы должны кинуть книгу "Linux-programming", отвечающую обоим критериям сразу?!

Или вот, создание файлов-синонимов. Допустим у нас есть куча командных файлов, вызывающих некоторую программу program_name.exe, которая в новой версии внезапно превращается в program_name6.exe или вообще меняет свое имя.

В подобных случаях начинающие администраторы прибегают к дублированию файлов, что не только транжирит дисковое пространство, но и создает проблемы синхронизации. Как быть, если два пользователя USER_A и USER_B хотят видеть _один_ и _тот_ _же_ файл file_name.doc в своих собственных домашних директориях, причем так, чтобы изменения, внесенные одним из них, тут же отражались у другого? Постое дублирование тут уже отдыхает и приходится задействовать жесткие ссылки, которые легко создать, например, с помощью FAR'а по <ALT-F6>. Внешне это выглядит как копирование файла, но в действительности файл (физически) остается один, вот только на него ссылаются два имени из двух (разных) директорий. Количество жестких ссылок формально ничем не ограничено и они очень полезны для сохранения старой структуры файлов на сервере при проведении его реконструкции.

{{s2k3rk_Image_2.png}}

**Рисунок 3 создание жестких ссылок (hard links) при помощи файлового менеджера FAR**

Просто создаем средствами сервера виртуальную папку /old/, куда и "копируем" посредством жестких ссылок все прежние файлы, уже растасованные по новым папкам. В результате, перерасхода дискового пространства не возникает.

То есть еще как возникает!!! Удаление файлов происходит лишь тогда, когда счетчик ссылок обращается в ноль и если у файла есть несколько астральных двойников, но после удаления одного из них место на диске не освободится. Возникает резонный вопрос: как найти все жесткие ссылки?!

Вот тут-то нам и пригодится утилита HLScan ("Hard Link Display"), выводящая список файлов, имеющих более одной жесткой ссылки с полными путями к ним, демонстрационный пример использования которой показан ниже:

<code>
D:\BIN\Windows Resource Kits\Tools>hlscan.exe
Hard Links Report for \\S2K3VM
Report Time: 03/08/2008 05:07:26
Scanned Areas: D:\


Hard Links Found in D:\ (recursive search):


ID: 0x2000000000922 - Hard Links Count: 2 - Missing: 0
  Creation Time: 03/04/2008 01:17:19
  Last Access Time: 03/04/2008 01:22:32
  D:\BIN\666.sys
  D:\BIN\KPNC\hack\km_anti_debug_base.sys

Summary:
        Files scanned: 1969
        Physical files with more than one name: 1
        Hard links: 2

Warning: 1 files or directories could not be scanned.
Check D:\BIN\Windows Resource Kits\Tools\HLScan.err for details
C:\WINDOWS\PCHEALTH\HELPCTR\BINARIES\HelpCtr.exe -mode C:\WINDOWS\help\rktools.xml
</code>

**Листинг 1 вывод списка файлов, содержащих более одной жесткой ссылки**

===== коза + баян == Resource Kit =====

Далеко не все утилиты, входящие в состав Кита полезны, а многие откровенно избыточны. Такое впечатление, что их писали программисты не читавшие даже штатную справку к операционной системе. Определенно не читали!!!

Ярчайший пример — утилита now.exe из Кита, позволяющая выводить текущее время на стандартный поток вывода (консоль), файл или "скармливать" его другой программе. Обратная операция – установка текущего времени, выполняется аналогичным образом, стоит только развернуть принцип на 180 градусов.

В справке написано, что это очень удобно в командных файлах. Действительно, при выполнении определенных действий (архивация, копирование файлов, прожиг на диск) полезно отметить в log-файле время начала и конца операции, что можно сделать следующим образом:

<code>
D:\BIN\Windows Resource Kits\Tools>now.exe

Sat Mar 08 05:17:26 2008
D:\BIN\Windows Resource Kits\Tools>hlscan.exe
Hard Links Report for \\S2K3VM
Report Time: 03/08/2008 05:07:26
</code>

**Листинг 2 использование утилиты now.exe из Кита для вывода текущего времени**

Красиво, конечно и весьма практично. Вот только, еще начиная с ранних версий NT текущая дата хранится в системной переменной DATE (а время, соответственно, в переменной TIME), содержимое которых может быть выведено через ECHO или любым другим путем, причем это будет _намного_ быстрее, чем загрузка целого EXE-файла. Установка даты/времени еще со времен MS-DOS осуществляется встроенным оператором командного интерпретатора "DATE".

<code>
C:\sys>echo %date% %time%
Сб 08.03.2008  5:29:32,54
</code>

**Листинг 3 вывод текущей даты/времени штатными средствами операционной системы**

Главный и, пожалуй, единственный недостаток переменных DATA/TIME, что формат вывода жестко фиксирован и привязан к региональным настройкам. То есть, если мы, например, написали простейший командный файл, архивирующий некоторые файлы и автоматически присваивающей имени архива дату его создания (чтобы было удобнее ориентироваться при поднятии с бэкапа), мы не сможем сформировать имя, согласно своим собственным предпочтениям, более того это имя будет меняться в зависимости от региональных настроек системы, что не очень-то приятно.

В UNIX-системах имеется специальная внешняя утилита, аналогичная now.exe, но позволяющая специфицировать формат вывода вручную, чего now.exe делать не умеет и потому ее назначение совершенно непонятно. Скорее всего, она просто была кинута до кучи и написана впопыхах, причем, никто из Microsoft ее не пользовался.

И это не единственный пример! Подобных утилит много, просто лень перечислять.

===== в дебрях Занзибара =====

"Не дайте себя обмануть в другом месте, покупайте только у нас!" говорилось в одной рекламе. Примерно таким же образом составлена и документация на MS Resource Kit 2003. Без глубокого знания системы в ней то, чтобы совсем нельзя разобраться, но очень легко впасть в грубые ошибки и вместо обещанного увеличения производительности нарваться на жестокую деградацию.

Рассмотрим это на примере двух утилит, предназначенных для подчистки памяти — Clear Memory (реализованной в файле Clearmem.exe) и Free Working Set Tool (реализованной в файле Empty.exe).Согласно своему названию, Clean Memory очищает память, что действительно, подтверждается показаниями "Диспетчера Задач" и производительность вроде бы и вправду увеличивается (иногда — значительно).

Интересно, за счет чего это достигается? Справка дает совершенно честный, но совершенно непонятный большинству непрограммистов ответ, достойный того, чтобы быть процитированным здесь: "//Clear Memory (ClearMem) is a command-line tool that determines the size of the computer's physical memory, allocates enough data to fill it, and references the data as quickly as possible. ClearMem also accesses files to clear the cache. This reduces, to a minimum, the memory available to other processes. Then, the Clear Memory tool releases the allocated memory to restore normal system functions//" ("Clean Memory представляет собой утилиту командой строки, которая определяет размер физической памяти компьютера, выделяет достаточное количество данных для ее заполнения и читает выделенный регион памяти на максимальной скорости. Clear Memory так же обращается к файлам для очистки дискового кэша. Это до минимума сокращает память, доступную другим процессам. Затем, Clean Memory освобождает выделенную память для восстановления нормального функционирования системы").

Ну?! Кто ни будь понял, чем реально занимается Clear Memory и что происходит с памятью?! Мыщъх понял, но только потому, что писал аналогичную утилиту еще во времена Widows 95, когда физической памяти катастрофически не хватало. Тогда она еще имела смысл, да и то лишь при просмотре фильмом. Сейчас же это просто средство ухудшить производительность.

Попробую объяснить ситуацию своими словами. Как известно, оперативная память имеет страничную организацию, при которой каждая страница адресного пространства может либо находится либо в физической памяти, либо в файле подкачки. При выделении блока памяти операционная система по умолчанию не предоставляет ему память вплоть до первого обращения к принадлежащим ему страницам, после чего просматривается список свободных физических страниц и происходит реальное выделение. Если же физическая память исчерпана, операционная система предпринимает попытку найти наименее нужную (с ее точки зрения) страницу памяти, и предоставить ее в распоряжение процесса. Если страница была модифицирована с момента своей загрузки, она попадает в файл подкачки, если же нет, то просто аннулируется и передается новому процессу. Все исполняемые файлы и динамические библиотеки на самом деле _проецируются_ в память, то есть сегмент кода никогда не вытесняется в файл подкачки (за исключением случаев, когда мы имеем дело с самомодифицирующимся кодом).

Эта схема имеет всего лишь один существенный недостаток — когда физическая память исчерпана, а вновь запущенное приложение потребляет ее блоками небольшого размера, то практически каждый акт выделения связан с обращением к файлу подкачки, в результате чего приложение некоторое время работает медленно (во всяком случае до тех пор, пока не выделит достаточное ему количество памяти).

Приложения реального времени (видеоплееры, программы захвата видео) при этом дохнут сразу. Изображение начинает дергаться, а захватываемые кадры — теряются. Но если предварительно запустить ClearMemory, то все будет ОК, поскольку она вытеснит на диск память всех процессоров (в том числе и те блоки, к которым процесс больше никогда не обратится) и мы получим в свое распоряжение максимум физической памяти. Как следствие, приложения реального времени будут исполняться нормально и без тормозов, но вот при обращении ко всем остальным приложениям — жесткий диск тут же взвоет, ведь принадлежащая ему память вытеснена на диск (или просто аннулирована) и теперь должна быть считана оттуда обратно.

На рабочих станциях это еще куда бы ни шло. Но вот на серверах… Да, на какое-то время мы получаем значительный выигрыш в производительности, и вновь подключающиеся клиенты обрабатываются с крейсерской скоростью, но вот все остальные процессы при первом же обращении к ним вызовут жуткие тормоза, пока память не будет скачена с диска обратно.

Самое забавное, что Clear Memory можно написать всего за пять минут, уложившись в десяток строк кода, а если программировать лень — просто запустить несколько "монструозных" приложений и тут же закрыть их, освободив принадлежащую им память. Радует лишь тот факт, что Clear Memory работает на всей линейке операционных систем от Microsoft: 95/98/ME/NT 4.0/W2K/XP/Server 2003 и (хотя это не указано в справке) на Висле и Server 2008.

Утилита Free Working Set Tool работает аналогичным образом, но позволяет указать PID процесса, чей Working Set необходимо скинуть на диск. Working Set представляет собой фрагмент адресного пространства, используемого процессом, куда попадают и системные библиотеки (разделяющие одну и ту же область физической памяти) и его собственные данные (они же приватные). В принципе, если у нас имеется процесс (несколько процессоров) выделивших данные, но уже давно к ним не обращающиеся, то при недостатке физической памяти операционная система вытеснит их на диск и сама. Зачем это делать нам?! Разве что нам необходимо получить большой кусок физической памяти для запуска приложения реального времени (вроде упоминающейся программы видео захвата), тогда мы, действительно, можем скинуть память ненужных процессов на диск, чтобы она нам не мешалась.

В некоторых статьях утверждается, что утилиты Clear Memory/Free Working Set Tool позволяют справится с утечками памяти, но это не так. Проблема утечек действительно имеет место быть и происходит всякий раз, когда сервер циклически выделяет блоки памяти, но не освобождает их, что ведет к росту файла подкачки и неуклонному исчерпанию адресного пространства (которого в зависимости от конфигурации сервера имеется от 2х до 3х гигабайт, независимо от объема физической памяти).

Clear Memory/Free Working Set Tool, конечно, могут вытеснить выделенную, но неиспользуемую память в файл подкачки, но лучше от этого никому не станет, ведь проблема в исчерпании адресного пространства (объема виртуальной памяти), а не физической. Освободить же неиспользуемую память не может ни Clear Memory, ни Free Working Set Tool, ни какая либо другая утилита, поскольку не существует способа, позволяющего отличать полезную память от бесполезной.

===== заключение =====

Критический разбор Кита не значит, что это плохая штука. Мыщъх ничего подобного не говорил! В его состав входит множество полезных утилит, правда бесполезных — еще больше, что запутывает администраторов, заставляя их отделять зерна от плевел, хотя по идее, эту работу должны были выполнить сотрудники Microsoft, предоставив народу тот набор инструментальных средств, который ему реально нужен, а не валить все в кучу. Впрочем, это мое личное субъективное мнение, отнюдь не претендующее на глобальную истину в первой инстанции. Чтобы составить свое мнение, достаточно скачать Кита и немного проиграться с ним. Вреда это не принесет, а вот польза будет немалая и весьма ощутимая.


